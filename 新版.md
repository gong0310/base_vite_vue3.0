[TOC]

**欢迎点击: [个人博客](https://blog.csdn.net/qq_41560520?type=blog)**

## 一、React

### 1、React响应式原理

​	1、一开始`jsx`语法经过babel编译,会被Babel编译为`React.createElement`方法,创建虚拟`dom`(render)，虚拟dom->真实dom，setstate数据改变的时候,会再生成一个虚拟dom,该虚拟dom与前一个虚拟dom通过diff算法**标记(就好比key)**(递归遍历)就行部分更新

​	2、React框架在接收到用户的状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff    算法计算出树中变化的部分，然后只更新的部分（Dom操作），从而避免整颗树重构，提高性能

状态变化后React框架并不会立即去计算并渲染DOM树的变化部分，相反，React会在DOM的基础上建立一个抽象层，即虚拟DOM树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到真实DOM中，而不是而每次改变都去操作一下DOM

****



### 2、diff运算

1、把树形结构按照层级分解，只比较同级元素

2、给里面结构的每个单元添加唯一的key属性，方便比较

3、React只会匹配相同class的component

4、合并操作，调用component的setState方法的时候，React将其标记为dirty.到每一个事件循环结束，React检查所有标记dirty的component重新绘制

5、选择性子树渲染。开发人员可以重写shuldComponnentUpdate提高diff的性能

**setstate是个异步，  多次合并区别，执行一次渲染**



### 4、JSX

是javascript xml 的语法糖，替代了React.createElement纯js方法，配合@babel/perset-react插件，就可以早在webpack编译时，把所有的jsx都改成React.createElemen

在 JSX 中不能使用 **if else** 语句，但可以使用 **conditional (三元运算)** 表达式来替代。以下实例中如果变量 **i** 等于 **1** 浏览器将输出 **true**, 如果修改 i 的值，则会输出 **false**.

在 JSX 中使用 JavaScript 表达式。表达式写在花括号 **{}** 中

首字母必须大写

浏览器无法解析

行内样式书写==>style={{color:'red'}}

注释需要写在花括号中{}



****

React中5种创建组件的方法

```
//ES5组件
React.createElement()
```

```
//ES6的类组件
class User extends React.Component{}
```

```
/高阶组件
//接收一个组件作为参数，在返回一个新组件
fucntion Hoc(child){

}
```

```
Hooks组件 
```

```
纯函数组件
```



### 5、生命周期

#### Mount（挂载阶段）

- constructor

  - ```
    初始化数据，调用构造函数
    ```

- getDerivedStateFromProps

  - ```
    调用render方法之前调用，并且在初始挂载及后续更新时会被调用。它返回一个对象来更新state,如果返回null,则不更新任何内容。
    ```

- render

  - ```
    渲染函数，在组件state没有变动的情况下，每次调用时都返回相同的结果，而且只能是纯函数，不能在这个阶段修改state
    ```

- componentDidMount

  - ```
    在组件中挂载后（插入DOM树中，立即调用）依赖于DOM节点的初始化应该放在这里。如需通过网络请求获取数据在这里请求。
    可以在这里直接调用setState()
    它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前
    ```

#### UpDate(更新阶段)

- getDerivedStateFromProps

  - ```
    调用render方法之前调用，并且在初始化挂载及后续更新时会被调用。它返回一个对象来更新state，如果返回null则不更新
    ```

- ShouldComponentUpdate(nextProps, nextState)

  - ```
    ShouldComponentUpdate的默认返回true，由于组件更新机制(shouldComponentUpdate()默认返回true)，父组件更新时，其内包含的子组件也会更新，为避免不必要重新渲染(性能浪费),使用shouldComponentUpdate,通过比较这新旧nextProps/nextState两个是否一样，决定是否重新render
    
    或者直接使用PureComponent（纯组件）,PureComponent重写了ShouldComponentUpdate()，内部自动帮我们处理了对比前后值来决定是否重新渲染
       注意:
    		只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false
    		不要直接修改state数据, 而是要产生新数据
    		项目中一般使用PureComponent来优化
    		
    hooks使用 React.memo(function MyComponent (props) {
      return <div>{ "My Component " + props.value }</div>;
    }) 
    ```

- render

  - ```
    渲染函数，在组件state没有变动的情况下，每次调用时都返回相同的结果，而且只能是纯函数，不能在这个阶段修改state
    ```

- componentDidUpdate

  - ```
    会在更新后立即被调用。首次渲染不会执行此方法当组件更新后，可以在此处对DOM进行操作。如果你对更新前后的props进行比较，也可以在此处进行网络请求
    ```

    

#### UnMounting(卸载阶段)

- componentWillUnmount

  - ```
    componentWillUnmount()会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除timer，取消网络请求或清除在componentDidMount中创建的订阅
    ```

    

### 已被废除的生命周期

- componentWillMount     挂载阶段
- componentWillReceiveProps   更新阶段
- componentWillUpdate     更新阶段

***

### 3、Redux

Redux是基于flux思想创建出来的react状态管理工具，是现在市场主流的React状态管理工具

#### Redux三大原则

- 单一数据源

  - ```
    整个应用的state被储存在一棵object tree中，并且这个object tree只存在于唯一一个store中
    ```

- State只读

  - ```
    唯一改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象
    
    这样确保了视图和网络请求都不能直接修改state，相反它们只能表达想要修改的意图，因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行。
    Action就是普通对象而已。
    ```

- 必须使用纯函数reducer来执行修改

  - ```
    为了描述action如何改变state tree,你需要编写reducers
    Reducer只是一些纯函数，它接收先前的state和action，并返回新的state。刚开始你可以只有一个reducer，随着应用变大，你可以把它拆成多个小的reducers，分别独立地操作state tree 的不同部分，因为reducer只是函数，你可以控制他们被调用的顺序，传入附加数据，甚至编写可复用的reducer来处理一些通用任务，如分页器
    ```

****

#### Redux基础

- #### Action

  - ```
    action是把数据从应用传到store的有效载荷。它是store数据的唯一来源。一般来说你会通过store.dispatch（）将action传到store
    
    action是一个用于描述已发生事件的普通对象
    
    只是描述了有事情发生了，这一事实，并没有描述应用如何更新state
    ```

- #### Reducer

  - ```
    Reducers指定了应用状态的变化如何响应actions并发送到store的
    ```

    

- #### Store

  - ```
    Store把reducers和action联系起来的对象，是所有数据储存、更新的场所，也就是state状态管理工具
    ```

****

#### 异步Action

需要使用第三方中间件（redux-thunk）把一步异步的action转化成三步同步action

```
import { applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
```

1、通知reducer请求开始的action

2、通知reducer请求成功的action

3、通知reducer请求失败的action

***

#### redux工作流程

通过Provider组件使得其它组件可以获取到state值，当组件想要获取state，此时的组件通过connect方法和mapStateToProps、mapActionToprops方法，已经能获取state，可以dispatch（action）到reducers中，reducers通过已经传过来的action，得到了变化的state，将值赋给原有的state，返回新的state到Store中，最后将数据渲染到组件之中



根据组件的职责通常把组件 分为UI组件和容器组件

UI组件负责UI的呈现，

容器组件负责管理数和逻辑

两者通过React-Redux提供connect方法联系起来



****

### 4、React路由

安装react-router-dom

引入import {HashRouter, NavLink} from 'react-router-dom' 

#### HashRoute、historyRoute的区别

hash模式url里面永远带着#号，我们在开发当中默认是使用这个模式。那么什么时候要用history模式？

如果考虑url的规范的话，那么就需要使用history模式，因为history模式没有#号,history模式也有缺点，如果在本地测试环境中使用history模式是没有任何问题的，但当我们在项目上线的时候就会出现404错误，需要后端去处理，让后端配置一下apache或是nginx的url重定向

#### 声明式路由

```
<NavLink to={'./xxx/xx'}>(跳转方式)</NavLink>
<HashRouter>（路由模式包裹Route组件）
	<Route path="/xxx/xxx">（路径落地的地方）</Route>
</HashRouter>
```

#### 编程式路由

通过高阶组件或者react-router-dom中的withRouter

this.props.history.push()

```
import React from "react";
import {withRouter} from "react-router-dom";

class MyComponent extends React.Component {
  ...
  myFunction() {
    this.props.history.push("/some/Path");
  }
  ...
}
export default withRouter(MyComponent);
```

****

#### 动态路由传参

**第一种**

路由表中：

```
通过在Route的path属性中配置 /：id
<Route path='/sort/:id' component={sort}></Route>
```

Link处：

- ​	Html方式

  - ```
    Link处的to属性中可以设置to = {'/sort/'+'2'}
    ```

    

- ​	js方式

  - ```
    this.props.history.push（‘/sort/’+2）
    ```

接收页面

```
获取值通过 this.props.match.params.id接受传过来的值
```



**第二种**

通过query，前提：必须由其它页面跳过来，参数中才会被传递过来,不需要配置路由标，路由照常

```
<Route path='/sort' commponent={sort}></Route>
```

1、LInk处

- Html方式

  - ```
    <Link to={{path:'/sort',query:{name:'sunny'}}}></Link>
    ```

- js方式

  - ```
    this.props.history.push({path:'/sort',query:{name:'sunny'}})
    ```

接收页面

```
this.props.location.query.name
```



**第三种**

同query差不多

state在哈希模式下，刷新页面参数丢失。因为BrowserRouter的history里保留了参数信息

state参数不会显示在url里面，保密

Link处：

```
<Link to ={{path:'/sort',state:{name:'sunny'}}></Link>
```

js处

```
this.props.history.push({pathname:'/sort',state:{name:'sunny'}})
```

接收页面

```
this.props.location.state.name
```

**第四种**

search

```
{/* 向路由组件传递search参数 */}
<Link to={`/home/message/detail/?id=${msgObj.id}&title=${msgObj.title}`}>

// 接收search参数( id=1&title=消息 )，search参数需要解析才能使用
const { search } = this.props.location
const { id, title } = qs.parse(search.slice(1))

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/9ea72f8480594e63a26c36510d964254.png#pic_center)

```javascript
hooks：
useHistory,useParams,useLocation,useMatch
```

#### React路由懒加载

```
import React, {lazy ,Suspense} from 'react';
const First = lazy(() => import('./first.js'))
const Secornd = lazy(() => import('./secornd.js'))
           <Suspense fallback={<h1>loading.....</h1>}>
                    <Switch>
                        <Route path='/first/:id' component={First}></Route>
                        <Route path='/first/b' component={First}></Route>
                    {/* <Route path='/secornd' component={Secornd}></Route> */}
                        <Route path='/secornd' render={()=>{
                            // 路由守卫拦截
                            if(true){
                                <Secornd/>
                            }else{
                                <Redirect to='/login'/>
                            }
                        }}></Route>
                    </Switch>
                </Suspense>

```



```
npm i @loadable/component

const xxx = loadable(()=>import('./xxxx/xxx'))
```



#### React图片懒加载

- npm i react-lazyload -S

- ```
  import LazyLoad from 'react-lazyload';
  
  ```

- ```
  <LazyLoad
        scrollContainer='.category_content'
        scroll={true}
        // offset={100}
        height={100}
        placeholder={<img width="100%" height="100%" src={DreamLogo} alt="logo"/>}
      >
        <img
          src={dataItem.cover}
          style={{ width: '100%' }}
          alt=""
        />
      </LazyLoad>
  ```

  

****

### 代码分割

@loadable/component

```
const a = loadable(()=>import './xxxx')
```

### 12、withRoute

在当你无法获取到从高阶组件穿过来的或取history和location时你需要使用withRoute

你可以访问[`history`](https://reactrouter.com/react-router/web/api/history)对象的属性和最近[``](https://reactrouter.com/react-router/web/api/Route)的[`match`](https://reactrouter.com/react-router/web/api/match)经`withRouter`高阶组件。`withRouter`将通更新`match`，`location`和`history`道具给被包装的成分时，它呈现。

```
import React from "react";
import PropTypes from "prop-types";
import { withRouter } from "react-router";

// A simple component that shows the pathname of the current location
class ShowTheLocation extends React.Component {
  static propTypes = {
    match: PropTypes.object.isRequired,
    location: PropTypes.object.isRequired,
    history: PropTypes.object.isRequired
  };

  render() {
    const { match, location, history } = this.props;

    return <div>You are now at {location.pathname}</div>;
  }
}

// Create a new component that is "connected" (to borrow redux
// terminology) to the router.
const ShowTheLocationWithRouter = withRouter(ShowTheLocation);
```



***

### 5、高阶组件

高阶组件实际上就是一个纯函数（render也是纯函数）唯一的输入得到唯一的结果参数为组件，返回值为新组件

第一个参数必须是组件，返回为新组件

```

高阶组件就是一个函数，且该函数接受一个组件作为参数，然后在里面进行加工，可以按照需求写逻辑并传参数方到这个组件的props里面，并返回一个新的组件
和Vue 中的 mixins 作用是一致的
//第一个参数必须是组件
function hoc(WrappedComponent) {
	return class extends React.Component{
		constructor(props){
			super
		}
	}
}

作用：包装,增强组件功能—---接收要包装的组件，返回增强后的组件,命名以with开头
ui组件：普通的业务组件，代表着一种功能

两种方式
hoc()
@hoc
```

常见的高阶函数:
	定时器设置函数
	数组的forEach()/map()/filter()/reduce()/find()/bind()
	promise
	**react-redux中的connect函数**
	**react-router-dom里面的withRouter**

纯函数 

1.一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回) 

2.必须遵守以下一些约束   	

​	1)不得改写参数数据 	

​	2)不会产生任何副作用，例如网络请求，输入和输出设备 	

​	3)不能调用Date.now()或者Math.random()等不纯的方法   

3.redux的reducer函数必须是一个纯函数

------

### Context,children插槽

调用 React.createContext()创建Povider(提供数据),Consumer(消费数据)两个组件
redux也是用Provider

```
{/* 设置value属性，表示要传递的数据 */}
 <Provider value='pink'>
     <h3>Contextt父级发送:pink</h3>
     <Child />
 </Provider>
                
                
<Consumer>
   {data => (
         <div>
           孙孙子接收到数据:{data}
        </div>
   )}
</Consumer>
```

------

### ref

```
<input ref={this.txtref} />
 this.txtref = React.createRef()//创建一个ref对象--- React.createRef调用后返回一个容器，该容器可以存储被ref所标识的节点,专人专用
 console.log('结果=>', this.txtref.current.value);

//不推荐,过时，官方说效率不高，未来可能移除
 <input ref="aaa" />
  this.refs.aaa 获取


 <input ref={(c)=>{this.input1 = c}} 
  {input1 }=this获取

```

### 受控组件、非受控组件

受控组件:其值受到react控制的表单元素,(随着你的输入，值会存储到state里面，类似vue的双向绑定)
**好处:不需要ref**
非受控组件:现用现取,(直接操作dom),获取文本框的值

***

### Hook

他是一组函数api，只在最顶层使用Hook，不要在循环，条件或嵌套函数中调用Hook

也可以使用Eslint中配置强调Hook使用规则

#### useState

无状态组件中没有this，所以不能读取this。state，我们直接在组件总调用useState Hook

```
import React, { useState } from 'react';

function Example() {
  // 声明一个叫 “count” 的 state 变量
  const [count, setCount] = useState(0);
  const [todos,setTodos] = useState([{text:'学习 Hook'}])
  }
  
  useState()方法里面唯一的参数就是初始state
  返回值为：当前state以及更新state的函数
  在函数中直接用{count}显示当前count
  在class中显示当前count要用{this.state.count}
```



#### useEffect(又叫副作用)：开启长连接、调接口、DOM操作、定时器等，解决无生命周期问题

```
useEffect相当于
componentDidMount
componentDidUpdate
componentwillUnmount
这三个生命周期的合并
第一个参数是回调函数，并且需要一个返回值，返回值是为了清除长连接、定时器之类的，第二个参数是数组等开关
```

#### useContext==>自定义Hooks

****

### 7、父子组件之间传值

父向子传===>this.props

子向父组件传值==>需要绑定一个事件，事件是父组件传递过来的this.props.event来进行值的更替

```
父
this.state = {
	arr:[{
		"username":"opop",
        "text":"12333"
	},{
	"username":"llll",
	"text":"99999"
	}
	]
}
render() {
	return(
		<div>
			<ComentList arr = {this.state.arr}>
			 //这里把state里面的arr传递到子组件
			</Commponent>
		</div>
	)
}
```

子

```
 return()(
 <div className="list">
    <ul>
      {
         this.props.arr.map(item => { //这个地方通过this.props.arr接收到父组件传过来的arr，然后在{}里面进行js的循环
             return (
                        <li key={item.userName}>
                             {item.userName} 评论是:{item.text}
                        </li>
                     )
                    })
          }
    </ul>
             
  </div>
```

### React 父子组件的相互调用方法

子组件使用父组件的方法：使用 `this.props.父组件中定义的方法`

父组件使用子组件的方法：调用子组件时，给子组件绑定 ref ，然后通过 `this.refs.ref绑定的值.子组件中定义的方法`

PropTypes校验,先安装prop-types包

```
Cchilder.propTypes = {//小写
    name: PropTypes.number.isRequired,
    cons: PropTypes.func,
    //特定对象写法
    // obj:propTypes.shape({
    //     a:PropTypes.string,
    //     b:PropTypes.number,
    // }),
    // 不可空的任意类型
    //  requiredAny:PropTypes.any.isRequired,
    //PropTypes.any验证值为任意数据
}
//Props的默认值：
Cchilder.defaultProps = {
    name: 777
}
```





****

### 9、token获取流程

1. 前端页面进行登录操作，将用户名和密码发给服务器
2. 服务器进行校验，通过后生成token，包含信息有密匙、uid、过期时间等，然后返回给前端
3. 前端将token保存在cookie中，下次对服务器请求时带上，然后返回给服务器端
4. 服务器端对接收到的token进行校验。通过则进行相应的增删改查操作，并将数据返回给前端；未通过则返回错误码，提示错误信息，然后跳转到登录页



****

### 11、Mobx

- observeable（被观察）
  - 被observeable修饰的state数据将会暴露给整个app，各观察者组件都可以根据state值得变化做出响应
- observer（观察者）
  - 被observer修饰的组件，将会根据组件内使用到的被observable修饰得state得变化而自动重新渲染
- action
  - state值的修改需要在action函数中进行
- computed
  - get:基于state值，通过一些计算得到的新值并返回给调用者
  - set:get的相反运算，参数为一个值，由该值进行get函数中的反运算，得到对应的state值并赋予state
- autorun
  - 基于state的变化而触发的一系列行为（这些行为不改变state值、不产生新的数据），通常为日志纪录、请求发送、UI渲染



****



## 二、Vue2.0

### 什么是Vue

vue是一套用于构建用户界面的渐进式框架，核心是组件化和响应式

Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。

1、**易用性**

2、**灵活性**

3、**高效性**：超快的虚拟 DOM 和 diff 算法

### 响应式原理/数据双向绑定的原理

采用数据劫持结合发布者-订阅者模式的方式，在初始化vue实例时，遍历递归我们data里面每一个属性，通过ES5的Object.defindeProperty来劫持每个属性的setter，getter，当读取data中的数据时自动调用get方法，当修改data中的数据时，自动调用set方法，检测到数据的变化，会通知Watcher(订阅者)触发相应监听回调，重新render(涉及到模板编译原理)当前组件（子组件不会被重新渲染），生成新的虚拟DOM树，Vue框架会遍历并对比新虚拟DOM和旧的虚拟DOM树中每个节点的差别，并纪录下来，最后加载操作，将所有纪录的不同点，局部修改到真实DOM树上



**页面更新过程：**

采用数据劫持结合发布者-订阅者模式的方式，在初始化vue实例时，遍历递归我们data里面每一个属性，通过ES5的Object.defindeProperty来劫持每个属性的setter，getter，当读取data中的数据时自动调用get方法，当修改data中的数据时，自动调用set方法，同时调用里面的一个trigger函数进行更新渲染（可以理解为监听回调)。

1、把trigger函数通过queueJob函数放入任务队列里面，里面会通过includes查看是否已经存在进行去重.

2、然后遍历主任务队列调用queueFlush函数执行异步任务处理，里面重新render当前组件，将模板字符串转换成ast 语法树并且进行静态节点标记（子组件不会被重新渲染），生成新的虚拟DOM树。

3、新的虚拟dom和旧的虚拟dom进行对比(把树形结构按照层级分解，只比较同级元素，通过唯一的id（静态标记）进行区分)，最将所有纪录的不同点，局部修改到真实DOM树上，根据id进行排序，先渲染父节点，再渲染子节点， 这样可以避免不必要的子节点渲染

4、执行完主任务队列里面的任务之后，才执行nextick

------

vue的v-model指令实现了双向数据绑定，v-model是一个语法糖：v-bind:value和@input事件实现的；底层原理如上

***

### 虚拟DOM

虚拟DOM就是通过JS描述出来的dom树(AST节点树)，（js运行比真实dom渲染快是肯定的）。利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。

主要是为了优化性能，直接操作DOM非常浪费性能

在更新发生后，会存在两个 Virtual DOM，一个是数据已经更新的 Virtual DOM，另一个是之前一次的 Virtual DOM。通过 diff 算法对比新旧vnode，找到两个 Virtual DOM 之间是哪些地方的数据发生了变化，然后只对这些节点进行部分更新，从而达到提高性能的目的

虚拟DOM的缺点：
1. 代码更多，体积更大
2. 内存占用增大
3. 小量的单一的dom修改使用虚拟dom成本反而更高，不如直接修改真实dom快

 diff： 把树形结构按照层级分解，比较同级元素

![](https://img-blog.csdnimg.cn/cc4039e8dadd4cbc8011ea4467776a50.png)

***

### MVVM

**model-view-viewModel，通过数据劫持+发布订阅模式来实现。**

mvvm是一种设计思想。Model代表数据模型，可以在model中定义数据修改和操作的业务逻辑;view表示ui组件，负责将数据模型转换为ui展现出来。;而viewModel是一个同步view和model的对象。在mvvm框架中，view和model之间没有直接的关系，它们是通过viewModel来进行交互的。mvvm不需要手动操作dom，只需要关注业务逻辑就可以了， 降低代码耦合，提⾼视图或者逻辑的复⽤性

mvvm和mvc的区别在于：mvvm是数据驱动的，而MVC是dom驱动的。mvvm的优点在于不用操作大量的dom，不需要关注model和view之间的关系，而MVC需要在model发生改变时，需要手动的去更新view。大量操作dom使页面渲染性能降低，使加载速度变慢，影响用户体验。



mvc

**Model、View、Controller**，分别表示**数据、视图、控制器**

**MVC框架的优势：**

1. 应用广泛，几乎所有前端语言都有类似MVC的设计痕迹

2. 设计思想非常简洁，学习成本很低，新人上手非常容易。

**MVC框架的问题：**

MVC并没有对数据请求和处理逻辑代码应该放在哪一层做出明确地划分，因此一旦页面逻辑或交互稍微复杂，Controller就会变得很臃肿，代码也就越来越难维护。



**MVVM优点**

 1、可维护性高:  ViewModel分离了大部分Controller代码，代码简洁，后期的维护和优化比较容易。

 2、方便测试：开发中大部分Bug来至于逻辑处理，由于ViewModel分离了许多逻辑，可以对ViewModel构造单元测试。

 3、耦合性低：view 和 model 之间没有直接的关系
			一人负责逻辑实现、另一人负责UI实现；

 4、重用性高: 可以把一些视图逻辑放在一个ViewModel里面,让很多view/ViewController进

**MVVM框架的问题：**

看起来代码会比MVC多点

对于⼤型的应⽤程序，大的模块，视图状态较多，model很大， ViewModel 的构建和维护的成本都会⽐较⾼，不利于内存的释放。

**MVVM实现者**

- Vue.js
- AngularJS
- 微信小程序



### vue 中 key 值的作用

给每个节点一个唯一的标识, Diff算法可以正确的识别此节点, 作用主要是为了高效的更新虚拟DOM。

key值作为vnode的唯一标识(唯一的id)，在进行对比的时候快速定位。没有key就不会知道谁和谁进行对比，key值一样的数据如果没有变化就不更新，有变化（增加，删除，替换等）就更新。所以某些时候使用索引作为key是有问题的

### 虚拟dom和dom的区别：

1、虚拟DOM不会进行排版与重绘操作，虚拟DOM就是把真实DOM转换为javascript代码

2、虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要更改的部分，最后在真实DOM中进行排版与重绘，，减少过多的DOM节点排版与重绘损耗

3、真实DOM频繁排版与重绘的效率很低

4、虚拟DOM有效降低大面积的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部

5、使用虚拟DOM的损耗计算

​	总损耗 = 虚拟DOM增删改 + 真实DOM差异增删改

### vue中模板编译原理(render过程)

1.将模板字符串转换成ast 语法树（通过解析器parser）

> 将模板字符串会扔到 while中去循环，然后 一段一段的截取，把截取到的进行解析，直到最后截取结束，这时就解析成了ast 语法树

2.对ast 语法树进行静态节点标记，主要用来做虚拟dom的渲染优化（优化器optimizer）

3.使用ast 语法树生成render函数代码字符串（代码生成器generator ）

### 理解vue的单向数据流

父级 prop 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。但是反过来则不行

防止从子组件意外改变父级组件的状态，保证了数据可控性

### 谈一谈你对Vue组件化的理解

1、组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；

2、组件化开发能大幅提高应用开发效率、测试性、复用性等；

3、组件使用按分类有：页面组件、业务组件、通用组件；

4、vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；

5、合理的划分组件，有助于提升应用性能；

6、组件应该是高内聚、低耦合的；

### vue首次加载一秒白屏

1. 在public文件夹index.html文件夹下直接写静态loding/骨架屏
2. 服务端渲染(**ssr**)也可以解决首屏加载慢这个问题，因为服务端会把所有数据全部渲染完成再返回给客户端，但是有一个大问题，服务端压力大，重要的是node层，需要解决高并发的问题---**高并发是指在一段时间内能够处理大量的请求**
3. 路由懒加载
4. 使用Gzip压缩，减少文件体积,加快首屏页面打开速度

### 你了解哪些Vue性能优化方法

1. 路由懒加载

在引入路由时，使用箭头函数的方式进行引入：`const Home = () => import('./home.vue') `

2. keep-alive缓存页面

 keep-alive 包裹的组件在视图切换显示或者隐藏时，保持当前状态不会改变，不会被销毁

3. 使用v-show复用DOM：意思为v-if 和 v-for 和区别使用：当页面频繁的切换渲染组件的显示或者隐藏时使用v-show，如果只渲染一次那么使用v-if；

4. v-for 遍历避免同时使用 v-if；

5. 长列表性能优化：

   如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化；

   如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容☟

6. 事件的销毁：也可以把组件直接销毁，在beroreDestroy生命周期中

7. 图片懒加载：`<img v-lazy="/static/img/1.png">` [参考](https://github.com/hilongjw/vue-lazyload)

8. 第三方插件按需引入：如vant、element-ui组件库

9. 变量本地化：不要频繁的使用this.xxx获取数据，可在需要使用时先定义一个变量接收data或者methods中的数据或者方法；

10. 服务端渲染 SSR



### Vue 如何兼容 IE 

**Vue里面router-link在电脑上有用，在安卓上没反应怎么解决**

Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决

统一`babel-polyfill` 插件

**Vue2中注册在router-link上事件无效解决方法**

答： 使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件。

**请说下封装 vue 组件的过程？**

答：1. 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。

　　2. 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。

　　3. 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。

　　4. 封装完毕了，直接调用即可

**在 Vue 实例中编写生命周期 hook 或其他 option/propertie 时，为什么不使用箭头函数？**

箭头函数自己没有定义 this 上下文，而是绑定到其父函数的上下文中。当你在 Vue 程序中使用箭头函数（=>）时，this 关键字病不会绑定到 Vue 实例，因此会引发错误。所以强烈建议改用标准函数声明。

### 生命周期

- beforeCreate

  - ```
    （创建前）数据观测和初始化事件还未开始,vue实例的挂载元素el和数据对象data都为undefined，还未初始化
    data ----- undefind
    method --- undefind
    $el ------ undefind
    ```

- created

  - ```
    （创建后）完成数据观测、属性和方法的运算，数据对象有了，$el属性还为undefined还未初始化
    data ----- 数据观测(data observer) // 尽量不要在此处操作data
    method --- 可用
    $el ------ undefind
    ```

- beforeMount

  - ```
    (载入前)在挂载开始之前开始被调用，$el和data都初始化了，相关的render函数首次被调用，实例已经完成以下配置
    编译模板，把data里面的数据和模板生成html,但还未把HTML挂载到页面上
    data ----- 数据观测(data observer)
    method --- 可用
    $el ------ undefind
    ```

- Mounted

  - ```
    （载入后）在el被新创建的vm.$el替换并挂载到实例上去之后调用。实例已经完成以下配置
    用上面编译好的html内容替换el属性指向DOM对象。完成模板中的html渲染到HTML页面中。此过程进行ajax交互
    data ----- 数据观测(data observer)
    method --- 可用
    $el ------ 创建完成 // 如果使用到一些第三方的UI插件, 而且这个插件还需要被初始化, 那么, 必须在mounted中来初始化插件
    ```

- beforUpdate

  - ```
    （更新前）在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改章台，不会触发附加的重新渲染过程
    ```

- Updated

  - ```
    （更新后）在用于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DoM已经更新，所以可以执行依赖于DOM的操作，然而在大多数的情况下，因该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子子啊服务器端渲染期间不会被调用
    ```

- activated(){}    (组件激活时)        如果页面有 keep-alive 缓存功能, 这个函数会触发

  ```
  被 keep-alive 缓存的组件激活时调用。初始化操作放在actived里面，初始化操作放在actived里面
  ```

  - deactivated(组件停用时) 	被 keep-alive 缓存的组件停用时调用。在deactived里面，在里面进行一些善后操作


- beforeDestory

  - ```
    （销毁前）在实例销毁之前调用。实例仍然完全可用
    ```

- Destoryed

  - ```
    (销毁后)在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用
    ```



#### 补充知识点---nextTick、父子组件的执行顺序：

1. **vue请求数据放在created好还是mounted里好？**

   建议放在created里
   created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
   mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

   如果在mounted钩子函数中请求数据可能导致页面闪屏问题
   其实就是加载时机问题，放在created里会比mounted触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了。

2. **请你说说vue中$nextTick用法及原理**

   2.0. 原因

   `1.vue更新dom是异步更新的，在程序中修改完数据不会立即更新；
   2.更新过程是批量更新的，`

   2.1. 定义

   在下次 DOM 更新循环结束之后执行延迟回调。

   官方理解：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM 

   个人理解：$nextTick当中的操作不会立即执行，而是会等数据、和dom更新之后再执行。nextTick是同步执行的，同步的把里面的值放到异步队列里了

   **运行机制**

   所有的同步任务都是在主进程执行的形成一个执行栈，主线程之外，还存在一个"任务队列"，异步任务执行队列中先执行宏任务，然后清空当次宏任务中的所有微任务，然后进行下一个tick如此形成循环。

   ```
   同步任务
   代码从上到下按顺序执行
   
   异步任务
   1.宏任务
   script(整体代码)、setTimeout、setInterval、UI交互事件、postMessage、Ajax
   
   2.微任务
   Promise.then catch finally、MutaionObserver、process.nextTick(Node.js 环境)
   注意;Promise是同步代码，后面的.then才是异步
   ```

   **nextTick 就是创建一个异步任务，那么它自然要等到同步任务执行完成后才执行。**

   2.2. 应用场景

       在vue中，如果改变了dom内部绑定的值，立即获取dom的innerHTML，会出现拿到的还是原来的值，这个时候需要用this.$nextTick方法执行回调函数
       
       <div id="app">{{a}}</div>
       let vm = new Vue({
         el: '#app',
         data: {
           a: 1
         },
         mounted() {
           this.a = 2
           console.log('dom节点内容：', app.innerHTML) // 打印出来的还是1
       
         }
       })
       mounted() {
         this.a = 2
         this.$nextTick(() => {
           console.log('dom节点内容：', app.innerHTML) // 这样打印出来的就是2
         })
       }

3. **父子组件的执行顺序：**
   加载渲染过程

   ```
   父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
   ```

   子组件更新过程

   ```
   父beforeUpdate->子beforeUpdate->子updated->父updated
   ```

   父组件更新过程

   ```
   父beforeUpdate->父updated
   ```

   销毁过程

   ```
   父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
   ```

   组件data为什么必须是个函数(类似闭包的意思)：**如果data是一个对象，就会存在数据被共享的可能**(同一个存储空间)

***

###  vue 几种常用的指令

* v-if
* v-else
* v-html
* v-for
* v-bind

  *    

    ```
       <!-- 完整写法 v-bind: -->
         <div v-bind:class="className">"{{innerHtml}}"</div>
       <!-- 缩写 : -->
         <div :class="className">"{{innerHtml}}"</div>
    ```

* v-model
* v-show
* v-on   用于事件绑定

  *  

    ```
     		<!-- 完整写法 v-on: -->
            <div v-on:click="clickfunc">点击事件</div>
            <!-- 缩写 @ -->
            <div @click="clickfunc">点击事件</div>
    ```

* v-text
* v-once    只会执行一次渲染，当数据发生改变时，不会再变化

### Vue更新视图的数组方法有哪些？

push()：末尾添加，返回新的length，

pop()：末尾删除，返回移除项，

shift()：开头移除，返回移除项，

unshift()：开头添加，返回新的length，

splice()：删除、插入、替换，改变原数组，返回新数组，

sort()：对数组进行排序，改变原数组，返回新数组，

reverse() ：颠倒数组的数据顺序，改变原数组，返回新数组

```
// 变异方法名称
const methodsToPatch = [
 'push',
 'pop',
 'shift',
 'unshift',
 'splice',
 'sort',
 'reverse'
]

const arrayProto = Array.prototype
// 继承原有数组的方法
const arrayMethods = Object.create(arrayProto)

mutationMethods.forEach(method => {
  // 缓存原生数组方法
  const original = arrayProto[method]
  arrayMethods[method] = function (...args) {
    const result = original.apply(this, args)
    
    console.log('执行响应式功能')
    
    return result
  }
})
```



### scoped的原理

vue中的scoped 通过在css样式上加唯一不重复的标记:data-v-[hash](https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020)的方式(属性选择器)，以保证唯一（而这个工作是由过PostCSS转译实现的），达到样式私有化模块化的目的。

```css
.layout-right-header[data-v-7a7a37b1] {
    height: 60px;
    background-color: bisque;
}
vue3 提供了样式穿透:deep() 他的作用就是用来改变 属性选择器的位置
vue2 推荐 /deep/
```

如果是插槽选择器使用slotted

```vue
<template>
    <div>
        <A>
            <div class="a">私人定制div</div>
        </A>
    </div>
</template>
<script setup>
import A from "@/components/A.vue"
</script>
<style scoped>
.a{
    color:red
}
</style>
// 无效果的---------------
解决方案  slotted
<style scoped>
 :slotted(.a) {
    color:red
}
</style>
```

此外还有:global(div){}全局选择器

### Vue基础

- el

  - 挂载路由

- data

  - 存放所有数据，只有存放在该处的数据才具有响应式原理和双向绑定属性

- **computed**

  - 计算属性，取代了表达式放在这数据都可被动态的修改，计算属性只有在它的相关依赖发生了变化才会被重新求值

  - 比如 当一个属性受多个属性影响时就需要用到computed

  - ```javascript
    multiply() {
      return this.count * 3;
    },
    multiply: {
      get() {
        return this.count * 3;
      },
      set(newval) {
        this.count = newval / 3;
      },
    },
    ```

- metheds

  - 自定义事件，业务逻辑

- **watch**

  - 所监听的data数据，有任何一个发生变化，侦听器都会被触发、执行,

  - 比如监听 路由的变化、组件form表单emit、搜索数据
  
  - ```javascript
     watch:{
          '$route.path':function(newVal,oldVal){
            if(newVal === '/login'){
              console.log('欢迎进入登录页面');
            } else if(newVal === '/register'){
              console.log('欢迎进入注册页面');
            }
          },
         firstName(newval, oldval) {
           console.log(newval)
          this.fullName = newval + "---";
        },
        firstName: {
          handler(newval) {
            console.log(newval);
            this.fullName = newval + "---";
          },
          immediate: true, // 参数化默认执行一次
          deep: true,
        },
    }
    ```
    
  
- **filters 过滤器**

  - 1. 自定义私有过滤器

    ```
    /*将时间格式转换*/
    filters: {
        datefmt: function(input, formatstring){
            var year = input.getFullYear();
            var month = input.getMonth() + 1;
            var day = input.getDate();
            var hour = input.getHours();
            /*  用toString().padStart()方法可以保持时间两位数
            var hh = dt.getHours().toString().padStart(2, '0');
            var mm = dt.getMinutes().toString().padStart(2, '0');
            var ss = dt.getSeconds().toString().padStart(2, '0');
            */
            var minute = input.getMinutes();
            var second = input.getSeconds();
            var res1 = year + '-' + month + '-' + day;
            var res2 = year + '-' + month + '-' + day + ' ' + hour + '-' + minute + '-' + second;
            if(formatstring == "yyyy-mm-dd"){
                return res1;
            }else{
                return res2;
            }
        }
    }
    ```

    2. 自定义全局过滤器

    ```
    Vue.filter('datefmt', function(input){
        var day = input.getDate();
        var month = input.getMonth() + 1;
        var year = input.getFullYear();
        var res = year + "-" + month + "-" + day;
        return res;
    })
    ```

    3. 实例

    ```
    <div id="app">
        <!-- 过滤差值表达式的内容，可以接受多个过滤器 -->
        <p>{{ msg | msgFormat}}</p>
    </div>
    <script>
        /* 定义一个Vue全局的过滤器，名字叫做 msgFormat */
        /* 过滤器中进行一个回调函数，第一个参数永远是管道符前面传过来的值 */
        Vue.filter('msgFormat', function(msg){
            //字符串的 replace方法，第一个参数，除了可写一个字符串之外，还可以定义一个正则
            return msg.replace(/徐/g, "陈");
        })
        var vm = new Vue({
            el: '#app',
            data: {
                msg: "徐徐"
            }
        })
    </script>
    ```

- **directives 自定义指令**

  - 做权限按钮的功能、获取input焦点、文本Copy、只能输入正整数指令
  
  - ```
        <h3>directives</h3>
        <input v-focus="'哈哈哈'" type="number" />
        <button v-colorSwatch="'#ccc'">v-colorSwatch</button>
      
      // 局部指令
      directives: {
        focus: {
          bind(el, binding, vnode) {
            console.log( el, binding, vnode)
            /**
             * el：指令所绑定的元素，可以用来直接操作 DOM。
             * binding：一个对象，包含：
             *    name：指令名，不包括 v- 前缀。
             *    value：指令的绑定值，例如：v-my-directive=“1 + 1” 中，绑定值为 2。指令的参数可以是动态的
             *    oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变 都可用。
             *    expression：字符串形式的指令表达式。例如 v-my-directive=“1 + 1” 中，表达式为 “1 + 1”。
             *    arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。
             *    modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
             * vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
             * oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。
             */
            console.log('directives bind--->只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置')
          },
          inserted(el) {
            console.log('directives inserted--->被绑定元素插入父节点时调用 ')
            el.focus()
          },
          updated() {
            console.log('directives updated--->所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前')
          },
          componentUpdated() {
            console.log('directives componentUpdated--->指令所在组件的 VNode 及其子 VNode 全部更新后调用 ')
          },
          unbind() {
            console.log('directives inserted--->只调用一次，指令与元素解绑时调用 ')
          },
        },
        // colorSwatch: {
        //   bind(el, binding, vnode) {
        //     el.style.backgroundColor = binding.value
        //   }
        // },
        /* 指令简写: 这个function等同于把代码写到了bind和update中去 */
        colorSwatch: function (el, binding) {
          el.style.backgroundColor = binding.value
        }
      },
      
      // 全局指令
    Vue.directive("aaa", {
      inserted(el) {
        console.log("123");
        //元素聚焦
        el.focus();
      },
    });
    ```
  
    
  


#### **computed和watch的区别:**

computed需要return，watch不需要

计算属性缓存结果时每次都会重新创建变量，而侦听器是直接计算，不会创建变量保存结果

computed只计算data中的值，watch不只监听data还可以监听路由

* watch 擅长处理的场景: 一个数据影响多个数据

搜索历史(联想)数据,form表单组件

* computed 擅长处理的场景: 一个数据受多个数据影响

 购物车商品结算的时候；后台上传excel数据，返回多少条成功，多少条失败

##### 计算属性和方法的区别

1，计算属性是一个属性 必须要有返回值 methods不一定
2，方法没有缓存，每次调用方法都会导致重新执行，计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值。比如，定义一个computd :sum(){retutn 1+2}，在组件里面多次使用sum，sum里面只会调用一次。而如果是methods会执行多次
3，计算属性本质上是包含getter和setter的方法，getter没有参数，setter只有一个参数，而方法的参数不限。
5，计算属性含义上也是一个数据，可以读取也可以赋值，方法含义上是一个操作，用于处理一些事情

#### vue slot

答：简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，就是slot分发负责的活。

#### vue 常用的修饰符

##### 事件

* stop(阻止冒泡)

* sync(实现子组件修改父组件的值, 不能与表达式连用)

* prevent(阻止默认事件)

* passive(不阻止浏览器默认行为)

* native(根元素添加事件)

* self(只有点击事件源才会触发)

* capture(捕获)

* once(只触发一次)

##### 表单

* lazy(失焦或回车触发)

* number(转数字)

* trim(去除两端空格)

##### 键盘

* enter

* esc

* space

* up

* down



***



### Vuex（状态管理）

#### 什么是Vuex

Vuex 是基于vue的一种比较流行的状态管理工具，也可以理解为数据管理工具，实现对应用程序中的数据进行科学地流程化管理，目标是让数据变化可预期、可控。简单来说就是存储数据的地方，可以让每个组件都能访问到

Vuex 是一个专为 Vue 开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化



解决组件间的传参，多个组件间的数据共享

***

### Vuex核心概念

- State

  - 储存数据

- Getter

  - ```
    类似计算属性，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会重新计算
    ```
    
  - ```
      //  store.js
      state: {
        count: 0,
      },
      getters:{
        multiplyCount(state){
          return state.count*100
        },
      },
      modules: {
        namespaced: true, // 为了解决不同模块命名冲突的问题
        moduleA,
        moduleB,
      },
      
     // moduleA.js
    const moduleA = {
      namespace: true,
      state: {
        user: "龚",
      },
      mutations: {
        setUser(state, val) {
          state.user = val;
        },
      },
      actions: {
        Login({ commit }, userInfo) {
          console.log(userInfo);
        },
      },
    };
    export default moduleA;
    ```

  - ```
    <div class="about">
        count：{{ $store.state.count }} mapState: {{count}}
        <p>getter:{{ $store.getters.multiplyCount }}</p>
    </div>
    
    import { mapState, mapMutations, mapActions, mapGetters } from 'vuex'
    export default {
      computed: {
        ...mapState(['count']), // 在组件通过this就可调用，不用再写this.$store.state
        // ...mapState({ // 另一种写法
        //   count: state=>state.count,
        //   user: state=>state.moduleA.user
        // }),
        ...mapGetters(['multiplyCount']),
      },
      mounted(){
        console.log('mapState count=>',this.count) // 0
      },
    }
    </script>
    
    ```
    
    

- Mutation

  - 进行状态更改的地方，store.commit调用Mutation方法，也可通过它传送数据
    用于更改state中的数据（同步）。

  - mutation 里面只允许同步的去修改 state 数据。（虽然在mutation中可以异步的去修改state数据不会报错，但是会导致时间旅行等机制没有效果）

  - 如果异步的修改的化，有两个大方案

    1. 不涉及action。在组件上异步代码走完之后再去调用 mutation
    2. 使用 action

  - ```
    
    // 以载荷形式
    store.commit('increment'，{
      amount: 10   //这是额外的参数
    })
    
    // 或者使用对象风格的提交方式
    store.commit({
      type: 'increment',
      amount: 10   //这是额外的参数
    })
    ```

  - ```
      methods: {
        ...mapMutations(['undaptCountAdd', 'undaptCountMin','setUser']),
        // 定义别名方式
        // ...mapMutations({
        //   undaptCountAdd: 'undaptCountAdd',
        //   setUser: 'moduleA/setUser'
        // }),
        handelAddCount() {
          // this.$store.commit('undaptCountAdd', 2)
          // this.$store.commit('moduleA/setUser', '余')
          this.setUser('余')
        },
      }
    ```

    ```
     //  store.js
     mutations: {
        async undaptCountAdd(state, payload) {
          console.log("Vuex undaptCount", state, payload);
          state.count += payload;
        },
        undaptCountMin(state, payload) {
          console.log("Vuex undaptCountMin", state, payload);
          state.count -= payload;
        },
      },
     actions: {
        async undaptCountMinAction({ commit, state }, payload) {
          const count = await MockAxios(payload);
          commit("undaptCountMin", count);
        },
      },
    ```

    

- Action

  - ```
    类似mutaion,Action提交的是mutation，而不是直接变更状态
    ```

  - Action可以包含任意异步操作

  - 可以调用context.commit提交一个mutation

  - context.state和context.getters来获取state和getters

  - ```
      methods: {
        ...mapActions(['undaptCountMinAction']),
        // 定义别名方式
        // ...mapActions({
        //   changeNumber1ActionAlias: 'changeNumber1Action',
        //   changeNumber2ActionAlias: 'changeNumber2Action'
        // }),
        handelMinCount() {
          this.undaptCountMinAction(2)
          // this.$store.dispatch('undaptCountMinAction', 2)
          // 直接使用 vuex 绑定到 vue 原型上的 $store 这个对象的 dispatch() 方法
        },
      }
    ```

    

- Module

  - 将store分割成模块。每个模块拥有自己的state、mution、action等
  - namespaced:true==>让模块成为带有命名空间的模块

**action可以修改state吗？为什么不建议在action修改state**

不开启严格模式的情况下可以，但是不提倡，以防异步操作会带来的延迟问题。严格模式下控制台会抛异常且action是异步的

**在组件只能可以通过this.$store.state访问到状态，为什么不能在组件中直接修改state?**
为了保证数据是单向流动的，只能在store中操作数据，而组件只能够使用状态，不能修改。

能够修改state里的变量，并且是响应式的  ,若将vue创建 store 的时候传入 strict: true, 开启严格模式，那么任何修改state的操作，只要不经过mutation的函数就会报错

 throw error :  [vuex] Do not mutate vuex store state outside mutation handlers。

**什么时候应用vuex：**

> 多个组件共享数据，中大型项目

**Mutation不能使用异步函数，为什么必须是同步更新？**

官方文档表明：在 mutation 中混合异步调用会导致你的程序很难使用 devtool 调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？，总而言之就是 会造成状态改变的不可追踪

**vuex页面刷新数据丢失问题**

因为js代码是运行在内存中的，代码运行时的所有变量，函数也都是保存在内存中的。
 刷新页面时，以前申请的内存被释放，重新加载脚本代码，变量重新复制，所以这些数据要想储存在就必须储存在外部，例如：LocalStorage，SessionStorage 等。这些都是浏览器提供的API,让你可以将数据存储在硬盘上，做持久化储存。具体选择哪一个就根据项目实际需求来选择。

1. 用sessionStorage/localStorage

```
app.vue

//解决 页面刷新 数据丢失问题
  created() {
    //在页面加载时读取sessionStorage里的状态信息
    if (sessionStorage.getItem("store")) {
      this.$store.replaceState(
        Object.assign(
          {},
          this.$store.state,
          JSON.parse(sessionStorage.getItem("store"))
        )
      );
    }

    //在页面刷新时将vuex里的信息保存到sessionStorage里
    window.addEventListener("beforeunload", () => {
      sessionStorage.setItem("store", JSON.stringify(this.$store.state));
    });
  },
```



2. 第三方插件vuex-along/vuex-persistedstate等等

### Vuex与eventBus区别

大型应用方面，项目越来越大，组件塔里的组件越来越多，不同组件之间通信越来越多，代码段里不断的出现$emit和$on导致了以下几个主要问题

> 1. 代码逻辑性极具下降，可阅读性变低 
> 2. 对于每一个action父组件都需要一个on(或dispatch)一个事件来处理 
> 3. 你将很难查找到每一个事件是从哪里触发，满篇都是业务逻辑，维护性变低

store是一个仓库，仓库保存着项目的数据(store.state)

***

### vue 等单页面应用及其优缺点

#### 单页面: 

* 通俗一点说就是指只有一个主页面的应用, 浏览器一开始要加载所有必须的 html, js, css, 所有的页面内容都包含在这个所谓的主页面中.

#### 多页面:

​        就是指一个应用中有多个页面, 页面跳转时是整页刷新

​      

#### 优点:  

* 用户体验好, 速度块, 内容改变的时候不需要重新加载页面, 对服务器压力较小

* 前后端分离, 降低耦合度, 提升开发效率

* 不以页面为单位, 更多的采用组件化的思想, 代码结构和组织方式更加规范化, 便于修改和调整

#### 缺点:

* 首次加载需要加载大量的资源, 加载时间相对较长
* 容易造成css命名冲突
* 不利于 SEO 优化, 单页页面, 数据在前端渲染, 就意味着没有SEO
* 页面导航不可用, 如果一定要用导航前进, 后退, 需要自己建立堆栈管理

------



### vue路由

#### hash模式与history模式的区别

1、url地址表现不同，hash模式有#号，#及其后面的字符内容则为hash值，可通过`window.location.hash`获取；history模式没有；

2、实现原理不同，

hash模式：

- 通过location.hash改变hash跳转页面
- window.addEventListener监听hashchange事件
  		 

history模式是基于最新的HTML5里面history相关的api进行的一些操作：

- history.pushstate(), history.replacestate()改变url跳转页面。这两个api不会引起页面刷新
- window.addEventListener监听popstate事件，监听浏览器的前进与后退的行为

3、 兼容性不同

​	1）hash模式都可以兼容
​             history模式只能兼容到IE10及以上
​             vue的兼容性，是只能兼容到ie8

​	2） history模式会出现404找不到页面这种问题。需要后端配置相关的处理才行。而hash模式没有这个问题

`比如nginx配置 try_files $uri $uri/ /index.html;`

​	3） history模式时，重定向会有些问题，需要页面的名字叫index.html才行



abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

#### Vue-router跳转和location.href有什么区别

答：使用a标签 / location.href='/url'来跳转，简单方便，但是刷新了页面；

使用history.pushState('/url')，无刷新页面，静态跳转；

引进router，然后使用router.push('/url')来跳转，使用了diff算法，实现了按需加载，减少了dom的消耗。

其实使用router跳转和使用history.pushState()没什么差别的，因为vue-router就是用了history.pushState()，尤其是在history模式下。

#### 声明式路由

```
<router-link></router-link>
<router-view></router-view>

Vue.use(VueRouter)
const Foo = {template: '<div>foo</div>'}
const routes = [
	{path:'/foo',component:Foo}
]
const router = new VueRouter({routes})
const app = new Vue({
router
}).$mount('#app')
```

#### 编程式路由

```
this.$router.push({path:'/xxx'})
this.$router.replace()
```



#### 路由传参

第一种 动态路由传参

```
routes:[
	path:'/XXX/:id',
	component:xxx
]

1、html方式
<router-link to="/xxx/xxx/123"></router-lnk>
2、js方式
this.$router.push({
	path:'/xxxx/${id}'
})

获取动态路由的id
$route.params.id
```

第二种 parmas

```
通过路由属性中的name来确定匹配的路由，通过params来传递参数，刷新页面，parmas数据会丢失
this.$router.push({
	name:'Describe',
	parmas: {
	id:id
	}
})

对应路由配置：这里可以添加:/id,不添加数据会在url后面显示，不添加数据就不会显示。但是刷新页面，parmas数据不会丢失

{
path:'/describe',
name:'Describe',
component:Descrbe
}

子组件获取参数
this.$route.params.id

```

第三种 query

```
父组件：使用path来匹配路由，然后通过query来传递参数
这种情况下query传递的参数会显示在url后面？id？
thi.$router.push({
	path:'/describe',
	query:{
		id:id
	}
})

对应路由配置：
{
	path:'describe',
	name:'Describe',
	component:Describe
}
对应子组件：这样来获取参数
this.$route.query.id
```

#### params 和 query 的区别

* 使用`params` 传参只能使用name进行引入, 且params是路由的一部分, 必须在路由后面添加参数名, 如果在跳转时没有传递这个参数, 回到是跳转失败或者页面会没有内容

* query 得写法是 用 path 来编写传参地址，而 params 得写法是用 name 来编写传参地址

* query 传得参数都是显示在url 地址栏当中；刷新页面得时候参数不会丢失

* params 传参不会显示在地址栏； 刷新页面得时候会参数丢失。不过在路由配置(:msg )，也可以显示在url 地址栏当中，且参数不会丢失

  ```
        routes: [
          path: '/XXX/:msg',
          component: xxx
        ]
  ```

 route 是路由对象信息 而 router 是路由对象的 实例

#### 路由守卫

- ##### 全局守卫

  - ```
    /*在跳转之前执行*/
    router.beforeEach((to, from, next) => {})
    
    next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航v
    
    比如：
    1.做登陆校验,权限判断，如果直接从url进入home页，如果没有token登录或不是白名单，则返回登录页
    2.动态路由菜单，不同用户对应不同的侧边菜单栏
    3.修改网页标题(meta取值)
    4.跳转加载进度条
    ```
    
  - ```
    /*在跳转之后判断*/
    router.afterEach((to,from) => {})
    ```
  
- ##### 局部守卫

  - ```
    const Foo = {
      template: `...`,
      beforeRouteEnter (to, from, next) {
        // 不！能！获取组件实例 `this`
        // 因为当守卫执行前，组件实例还没被创建，可以通过vm获取实例进行操作
        next(vm=>{
        
        })
      },
      beforeRouteUpdate (to, from, next) {
        // 在当前路由改变，但是该组件被复用时调用
        // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
        // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
        // 可以访问组件实例 `this`
      },
      beforeRouteLeave (to, from, next) {
        // 导航离开该组件的对应路由时调用
        // 可以访问组件实例 `this`
      }
    }
    比如: 监听$route
    ```
    
  
- **路由独享守卫**

  - ```
      {
        path: '/',
        name: 'Home',
        meta:{title:'首页'},//自定义路由信息，在页面$router.matched获取所有路由信息，然后filter
        component: Home,
        beforeEnter:((to,from,next)=>{
          console.log('路由独享的守卫===',to)
          next()
        })
      },
    ```

- 通过路由记录的 `meta` 属性可以定义元信息可以在路由中附加自定义的数据，例如：

  - 权限校验标识。
  - 路由组件的过渡名称。
  - 路由组件持久化缓存 (keep-alive) 的相关配置。
  - 标题名称


#### Vue路由懒加载

```
按原先import  xxx from "/xxxx.Vue，方式，会在一开始就调用执行，影响内存和运行速度，用路由懒加载时，你只有需要到改组件才会引入调用

const Foo = () => import(/* webpackChunkName: "Foo" */ './Foo.vue')
```

#### keep-alive，transition

keep-alive当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

作用：防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。

生命周期上面有讲解

```
<transition name="fade" mode="out-in">
  <keep-alive>
  	<router-view v-if="$route.meta.keepAlive">
          <!-- 这里是会被缓存的视图组件-->
 	</router-view>
 </keep-alive>
 <router-view v-if="!$route.meta.keepAlive">
        <!-- 这里是不被缓存的视图组件 -->
 </router-view>
</transition>

<style scoped lang="less">
.fade-enter-active,
.fade-leave-active {
  transition: opacity 2.5s;
}

.fade-enter,
.fade-leave-to {
  opacity: 0;
}
</style>
```

```
      {
        path: "routerA:msg",
        name: "RouterA",
        meta: { keepAlive: true },
        component: () =>
          import(/* webpackChunkName: "routerA" */ "../views/RouterA.vue"),
      },
      {
        path: "routerB",
        name: "RouterB",
        meta: { keepAlive: true },
        component: () =>
          import(/* webpackChunkName: "routerB" */ "../views/RouterB.vue"),
      },
```

或直接使用

```
// 1. 将缓存 name 为 test 的组件
  	<keep-alive :include='["test"}'>
      <router-view/>
    </keep-alive>
	
	// 2. 将缓存 name 为 a 或者 b 的组件，结合动态组件使用
	<keep-alive include='a,b'>
  	  <router-view/>
	</keep-alive>
	
	// 3. 使用正则表达式，需使用 v-bind
	<keep-alive :include='/a|b/'>
  	  <router-view/>
	</keep-alive>	
	
	// 5.动态判断
	<keep-alive :include='includedComponents'>
  	  <router-view/>
	</keep-alive>
	
	// 5. 将不缓存 name 为 test 的组件
	<keep-alive exclude='test'>
  	  <router-view/>
	</keep-alive>
```



#### Vue图片懒加载

- npm i vue-lazyload -s

- 引入import VueLazyLoad from ``'vue-lazyload'

- ```
  Vue.use(VueLazyLoad,{
  error:'', //加载失败的图
  loading:'' //加载中的默认图
  })
  ```

- ```
  <ul>
   <li v-for="img in list">
    <img v-lazy="img.src" >
   </li>
  </ul>
  ```

  



****

### 父子组件传值

父传子props

```
1、子组件在props中创建一个属性，用以接收父组件传过来的值
2、父组件中注册子组件
3、父组件在子组件标签中添加props中创建的属性把需要传给子组件的值赋给该属性
```

子传父（通过this.$emit(“方法”，要传的值)）

```
1、子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件
2、将需要传的值作为$emit的第二个参数，该值将作为实参传给响应自定义事件的方法
3、在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听
4、在通信中，无论是子组件向父组件传值还是父组件向子组件传值，他们都有一个共同点就是有中间介质，子向父的介质是自定义事件，父向子的介质是props中的属性。抓准这两点对于父子通信就好理解了
```



### extend 能做什么

这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 `$mount` 一起使用。

```
// 创建组件构造器
let Component = Vue.extend({
  template: '<div>test</div>'
})
// 挂载到 #app 上
new Component().$mount('#app')


// 除了上面的方式，还可以用来扩展已有的组件
let SuperComponent = Vue.extend(Component)
new SuperComponent({
    created() {
        console.log(1)
    }
})
new SuperComponent().$mount('#app')


// 使用Vue.extend来创建全局的Vue组件
var com1 = Vue.extend({
  template: '<h3>这是使用Vue.extend创建的组件</h3>'
})
Vue.component('Mycom1', com1); 
```

### mixin 和 mixins 区别

`mixin` 用于全局混入，会影响到每个组件实例，例如给全部文件添加一些公用的实例（如方法、过滤器等）。如果有公共的组件使用频率很高的话，可以使用mixin很方便的引入公共的部分

**全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到所有之后创建的 Vue 实例。**

相当于Vue3 的自定义的hook

```
// mixin.js

const mixin = {
  methods: {    
      two(num){
          return num*num
      }  
  }
}
export defaullt mixin
```

在main.js文件全局引入

```
import mixin from './mixin'
Vue.mixin(mixin)
```

其他vue页面里面就可以使用mixin里面定义好的方法，如：

```
 data() {
    return {
      name: "abc",
      square: this.two(3)
    }
  }
```

`mixins` 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 `mixins` 混入代码，比如上拉下拉加载数据、窗体禁止拖拽这种逻辑等等。

另外需要注意的是 `mixins` 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 [文档](https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fmixins.html)。



![img](https://upload-images.jianshu.io/upload_images/8066565-ee5741cace0b2bb6.png?imageMogr2/auto-orient/strip|imageView2/2/w/759/format/webp)

###  vue 和 jQuery 的区别

* `JQuery` 提高了开发效率，进行了很多dom操作封装
* `Vue`  是一套用于构建用户界面的渐进式JavaScript框架

##### 区别: 

* `jQuery` 

  本质还是操作dom,必然带来性能的损耗(性能不友好，大量的重绘与重排，回流)，效率低

  没有做业务分层，没有组件化编码方案，代码全部写在一起，代码复用率低

* `Vue` 是虚拟dom，使用虚拟dom+优秀的diffing 算法，尽量减少与真实dom的交互

### Vue与react有什么区别

答：

不同：

- vue封装了很多指令而react没有；
- Vue的设计模式是mvvm，react的是mvc模式；
- Vue有全局组件，而react没有这个概念；
- Vue数据是双向绑定的，而react是单向数据流；
- Vue没有受控组件和非受控组件的概念，而react有。
- React有新的语法——JSX，子级调用父级方法向父级传参也是props；Vue.把html，css，js组合到一起，使用了基于 HTML 的模版语法
- vue通过slot插槽进行嵌套传递，react通过“props.children”的方式将标签内的部分传递给子组件

相同：

- 利用虚拟DOM实现快速渲染 
- 都是轻量级 和组件化 
- 有相应的集成路由工具，打包工具以及状态管理工具 
- 都支持服务器端渲染

****

## 三、Vue3.0

### **与vue2.0对比:**

- Vue3支持大多数的Vue2的特性。如果3.0项目中2.0跟3.0混搭写法,方法重名的话3.0优先
- **Vue3中设计了一套强大的组合APi(Compostion API，Setup 函数式编程 也叫vue Hook)代替了Vue2中的option API ,复用性更强了。可自定义hook函数，不需要代码都写在一个template(再也不怕代码多起来，滚轮滚到手发抖了)---面向对象编程--->函数式编程**
- **按需编译，体积比Vue2.x更小**

```
Tree shaking：

在Vue2中，很多函数都挂载到全局 Vue 对象上，如：nextTick、set 函数等，虽然我们不常用，但打包时只要引入 Vue 这些全局函数会打包进 bundle 中

而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果你不使用其某些功能，它们将不会包含在你的基础包中
比如你要用watch 就是import {watch} from 'vue' 其他的computed 没用到就不会给你打包减少体积
```



- **Vue3更好的支持[TypeScript(TS)](https://blog.csdn.net/qq_41560520/article/details/116595054)**



- **Vue3 优化Vdom,响应式性能提升**

```
diff 方法优化：

在Vue2中,每次更新diff,都是全量对比,Vue3则只对比带有标记(静态标记)的,这样大大减少了非动态内容的对比消耗，
数据发生变化时，会生成一个新的dom树，然后和之前的dom树进行比较，找到变更的节点然后更新到真实的dom上。在比较的过程中会对没有发生改变的dom也进行比较，这样消耗了一定的时间。
在vue3中，在创建虚拟dom时会根据dom的内容添加一个静态标记，在数据发生变化时就会带着静态标记的节点去对比，能够快速找到需要更新的dom。

新增了 patch flag（补丁标记）

TEXT = 1 // 动态文本节点
CLASS=1<<1,1 // 2 //动态class
STYLE=1<<2，// 4 //动态style
PROPS=1<<3,// 8 //动态属性，但不包含类名和样式
FULLPR0PS=1<<4,// 16 //具有动态key属性，当key改变时，需要进行完整的diff比较。
HYDRATE_ EVENTS = 1 << 5，// 32 //带有监听事件的节点
STABLE FRAGMENT = 1 << 6, // 64 //一个不会改变子节点顺序的fragment
KEYED_ FRAGMENT = 1 << 7, // 128 //带有key属性的fragment 或部分子字节有key
UNKEYED FRAGMENT = 1<< 8, // 256 //子节点没有key 的fragment
NEED PATCH = 1 << 9, // 512 //一个节点只会进行非props比较
DYNAMIC_SLOTS = 1 << 10 // 1024 // 动态slot
HOISTED = -1 // 静态节点
BALL = -2

patch flag 的强大之处在于，当你的 diff 算法走到 _createBlock 函数的时候，会忽略所有的静态节点，只对有标记的动态节点进行对比，而且在多层的嵌套下依然有效。
```



- **新的组件: Fragment(片段)(支持多个根节点) / Teleport(瞬移) / Suspense(不确定)**

- 设计了一个新的脚手架工具—vite,npm run dev 秒开，热重载也很快。这种开发体验真是很爽，拒绝等待。

- 全局 API 现在只能作为 ES 模块构建的命名导出进行访问

  

- **Vue3中v-if优先于v-for，移除过滤器**

- **重写双向绑定**

```
vue2
基于Object.defineProperty()实现
Object.defineProperty监听不到对象属性的、数组元素和长度的变化
 
vue3 基于Proxy
proxy与Object.defineProperty(obj, prop, desc)方式相比有以下优势：
 
//省去for in 循环
//可以监听数组变化，包括索引和 length 属性
//可以直接监听对象而不是它的属性，可以监听增删属性
//代码更简化
//proxy 不需要初始化的时候遍历所有属性，如果有多层嵌套的话，只访问某个属性的时候，proxy 能够快速访问到，而 Object.defineProperty 还需要遍历所有属性，然后逐级向下访问。
//proxy 返回的是一个新对象，可以直接操作新对象而达到目标。而 Object.defineProperty 操作的是原对象，只能遍历对象属性然后对其直接修改。
 
    let proxyObj = new Proxy(obj,{
        get : function (target,prop) {
            return prop in target ? target[prop] : 0
        },
        set : function (target,prop,value) {
            target[prop] = 888;
        }
    })  
```

- **Vue3 v-model** 
  - ​	默认值的改变
    - prop：`value` -> `modelValue`；
    - 事件：`input` -> `update:modelValue`；
    - `v-bind` 的 `.sync` 修饰符和组件的 `model` 选项已移除
    - 新增 支持多个v-model
    - 新增 支持自定义 修饰符


- 自定义指令的生命周期名字改变

- 定义全局变量发生改变

  - ```
    由于Vue3 没有Prototype 属性 使用 app.config.globalProperties 代替 然后去定义变量和函数
    
    // 之前 (Vue 2.x)
    Vue.prototype.$filters = {}
    
    // 之后 (Vue 3.x)
    const app = createApp({})
    app.config.globalProperties.$filters ={}
    获取:
    const instance = getCurrentInstance();
    console.log('instance',instance?.appContext.config.globalProperties)
    
    我们正好可以使用全局函数代替Filters
    ```

    



### vue2.X 和vue3.X 渲染器的diff算法区别

```
当data发生改变 会根据新的数据生成一个新的虚拟dom ，
新的虚拟dom和旧的虚拟dom进行对比(把树形结构按照层级分解，只比较同级元素，通过唯一的id（静态标记）进行区分)，这个对比的过程就是diff算法  


区别：
vue2会全量对比；

vue3不会去修改不需要对比的,只对比带有标记(静态标记)的，比如将变量赋值flag1，不变的值赋值flag，
只会对比变动的值，因此比vue2性能更好，他会查找模板中不同的数据,如果发现数据有不同就重新渲染模板，所以比Vue2速度要快
```

**vue与react的diff比较**

1. vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点，就像打补丁一样修改真实dom
2. vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。
3. vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个,同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅

### vueRouter 4.x

```
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/vue',
    name: 'Vue',
    component: () => import(/* webpackChunkName: "vue" */ '../views/Vue.vue')
  },
]
/**
 * 1. new Router 变成 createRouter
 * 2. 新的 history 配置取代 2.0 的mode配置
 * 3. 移动了 base 配置，base 配置被作为 createWebHistory (其他 history 也一样)的第一个参数传递
 * 4. 删除了 *（星标或通配符）路由
 * 5. 3.0的 router.onReady() 函数已被 router.isReady() 取代，该函数不接受任何参数并返回一个 Promise
 * 6. 删除 <router-link> 中的 event 和 tag 属性，使用 v-slot API 来完全自定义
 * 7. 所有的导航现在都是异步的
 */
const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})
router.isReady().then(()=>{ // 或者使用 await
  console.log('成功')
}).catch()

export default router

```

```
//main.ts

const app = createApp(App);
app.use(store).use(router);
router.isReady().then(() => app.mount('#app'))
// 所有的导航现在都是异步的，如果你使用一个 transition，你可能需要等待路由 ready 好后再挂载程序。否则会有一个初始过渡
```

> Vue Router 将更新和离开守卫作为 组合式 API 函数公开，不含前置守卫（*可以通过watch监听路由实现*）

> 动态路由： router.addRoute() 和 router.removeRoute() 
>
> router.hasRoute()：检查路由是否存在。
>
>  router.getRoutes()：获取一个包含所有路由记录的数组。

### vueX 4.x

Vuex 是基于vue的一种比较流行的状态管理工具，简单来说就是存储数据的地方，可以让每个组件都能访问到

**引入了全新的“useStore”组合式函数，vue3.0使用辅助函数需要进行二次封装**

```
  const store = useStore();
  
  const stateA = computed(() => store.state.A);
    // store.commit('aaa')
    // store.dispatch('aaa1')
    
  console.log("store stateA", stateA.value.aaa);
```

### Pinia 

实际上，pinia就是Vuex的升级版，官网也说过，为了尊重原作者，所以取名pinia，而没有取名Vuex，

所以可以直接将pinia比作为Vue3的Vuex5.0。

**为什么要使用pinia？**

1. Vue2和Vue3都支持，这让我们同时使用Vue2和Vue3的小伙伴都能很快上手。
2. pinia中只有state、getter、action，抛弃了Vuex中的Mutation、模块，pinia中action支持同步和异步。
3. 无需再创建各个模块嵌套了，Vuex中如果数据过多，我们通常分模块来进行管理，稍显麻烦，而pinia中每个store都是独立的，互相不影响。
4. 更好的Typescript支持，我们Vue3也是推荐使用TS来编写
5. 体积比vuex小
6. pinia支持插件来扩展自身功能。
7. 支持服务端渲染。

使用：

```
// user.ts
import { defineStore } from "pinia";

// 第一个参数是应用程序中 store 的唯一id，第二个option配置项,返回一个获取容器的函数
export const useUserStore = defineStore("users", {
  // 不需要.state.age，会自动把state，getters，actions里面的内容暴露出来，直接.age

  // 相当于组件中的 data
  /**
   * 1.必须是函数：这样是为了在服务端渲染的时候避免交叉请求导致的数据状态污染
   * 2.必须是监听函数：更好的ts类型推导
   */
  state: () => {
    return {
      name: "小猪课堂",
      age: 21,
      sex: "男",
    };
  },
  
  // 相当于组件中的 computed，有缓存
  getters: {
    getAddAge: (store) => {
      //   return store.age + 100;
      // 如果getters接收参数，则返回函数来获取参数
      return (num: number) => store.age + num;
    },
    getNameAndAge(): string {
      // this指向的便是当前store实例，感觉用vue2一样，如果是箭头函数,this就不是当前store实例而是undefined
      // 如果getters中使用了this，则必须手动设置返回类型，否则类型推导不出来
      return this.name + this.getAddAge(1000); // 调用其它getter
    },
  },
  
  // 相当于组件中的 methods,可以是异步的，可以是同步的
  actions: {
    saveName(name: string) {
      // 发送请求，拿token，取token
      this.name = name;
      const aaa: CartProduvt = {
        age: 111,
        name: "111",
      };
      console.log(aaa);
    },
  },
});

```

```
<script lang="ts" setup>
import { useUserStore } from "../pinia/user";
import { storeToRefs } from "pinia";

const store = useUserStore();

// let { name, age, sex } = store; // 直接解构会失去响应式，pinia其实就是把state数据都做了reactive处理
/**
 * 直接解构会失去响应式，使用storeToRefs解决，
 * 类似于toRefs()但专门为 Pinia 设计
 */
// 把解构出来的数据做ref响应式代理
let { name, age, sex, getAddAge, getNameAndAge } = storeToRefs(store);
// -------------------------------
// 1、修改单个state数据
const changeName = () => {
  // name = "张三"; 不可直接更改
  store.name = "张三";
  console.log(store);
};

// 2、重置store
const resetStore = () => {
  store.$reset();
  console.log(store);
};

// 3、修改多个state数据(批量更新)
// 方式一
// const changeAll = () => {
//   store.$patch({
//     name: "李四",
//     age: store.age++,
//   });
// };
// 方式二
const changeAll = () => {
  store.$patch((state) => {
    state.name = "李四";
    state.age++;
  });
};
// 方式三：逻辑比较多可以封装到actions里面
// -------------------------------

// 直接替换整个state对象
const changeReplace = () => {
   store.$state = { counter: 666, name: "张三2" };
};

const saveName = () => {
  // Actions 像 methods 一样被调用：
  store.saveName("我是小猪");
};
</script>

```



## 四、webpack

### 什么是webpack

webpack是一个打包模块化javascript的工具，在webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化项目。
WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。

### webpack有哪些优点

- 专注于处理模块化的项目，开发便捷
- 可通过plugin扩展，扩展性强，插件机制完善
- 使用场景不局限于web开发
- 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展
- 良好的开发体验

### webpack的缺点

webpack的缺点是只能用于采用模块化开发的项目

### 什么 是模块热更新？

模块热更新是webpack的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。
devServer中通过hot属性可以控制模块的热替换
通过配置文件

```
const webpack = require('webpack');
const path = require('path');
let env = process.env.NODE_ENV == "development" ? "development" : "production";
const config = {
  mode: env,
 devServer: {
     hot:true
 }
}
  plugins: [
     new webpack.HotModuleReplacementPlugin(), //热加载插件
  ],
module.exports = config;
```



### 1、配置文件的属性：

entry ==>入口

```
 entry: {
        bundle: [
            'webpack/hot/dev-server',
            'webpack-dev-server/client?http://localhost:8080',
            path.resolve(__dirname, 'app/app.js')
        ],
    },
    // 文件路径指向(可加快打包过程)。
    resolve: {
        alias: {
            'react': pathToReact
        }
    },
```

output ==>出口

```
 output: {
        path: path.resolve(__dirname, 'build'),
        filename: '[name].js',

```

moudule ===>*这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。*

plugins ==>*webpack 各插件对象，在 webpack 的事件流中执行对应的方法*（构建整个流程），是用来拓展webpack功能的，是一个具有 apply 属性的 JavaScript 对象，apply 属性会被 webpack compiler 调用，compiler 对象是 webpack 的编译器对象

Chunk:代码块，一个Chunk由多个模块组合而成，用于代码合并分割

****

### 2、有哪些常见Loader?他们是解决什么问题的

- file-loader
  - 把文件输出到一个文件中，在代码通过相对URL去引用输出的文件
- url-loader
  - 和file-loader类似,但是能在文件很小的情况下以base64的方式把文件内容注入到代码中去
- source-map-loader
  - 加载额外的收入Source Map 文件，以方便断点调试
- image-loader
  - 加载并且压缩图片文件
- babel-loader
  - 把ES6转换成ES5
- css-loader
  - 加载CSS，支持模块化、压缩、文件导入等特性
- style-loader
  - 把CSS代码注入到javaScript中，通过DOM操作去加载CSS 
- eslint-loader
  - 通过ESLint检查Javascript

### 3.有哪些常见的Plugin？他们是解决什么问题的？

- define-plugin：定义环境变量
- commons-chunk-plugin：提取公共代码
- uglifyjs-webpack-plugin：通过`UglifyES`压缩`ES6`代码
- mini-css-extract-plugin：分离css文件
- clean-webpack-plugin：删除打包文件

------

### 4、Loader和Plugin的不同

- **不同的作用**

  - **Loader**直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析*非JavaScript文件*的能力。
  - **Plugin**直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

  **不同的用法**

  - **Loader**在`module.rules`中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个`Object`，里面描述了对于什么类型的文件（`test`），使用什么加载(`loader`)和使用的参数（`options`）
  - **Plugin**在`plugins`中单独配置。 类型为数组，每一项是一个`plugin`的实例，参数都通过构造函数传入。

### 

***

### 5、webpack的构建流程是什么

- 初始化参数

  - ```
    从配置文件和Shell语句中读取与合并参数，得出最终的参数
    ```

- 开始编译

  - ```
    用上一步得到的参数初始化Compier对象，加载所有配置的插件，执行对象的run方法开始执行编译
    ```

- 确定入口

  - ```
    根据配置中的 entry 找出所有的入口文件；
    ```

- 编译模块

  - ```
    从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块的依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
    ```

- 完成模块编译

  - ```
    在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
    ```

- 输出资源

  - ```
    根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk,再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
    ```

- 输出完成

  ```
  在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
  ```



在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

------

### 6、如何提高webpack的构建速度？

1. 多入口情况下，使用`CommonsChunkPlugin`来提取公共代码
2. 通过`externals`配置来提取常用库
3. 利用`DllPlugin`和`DllReferencePlugin`预编译资源模块 通过`DllPlugin`来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过`DllReferencePlugin`将预编译的模块加载进来。
4. 使用`Happypack` 实现多线程加速编译
5. 使用`webpack-uglify-parallel`来提升`uglifyPlugin`的压缩速度。 原理上`webpack-uglify-parallel`采用了多核并行压缩来提升压缩速度
6. 使用`Tree-shaking`和`Scope Hoisting`来剔除多余代码

### 7、如何利用webpack来优化前端性能？(提高性能和体验)

用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效

- 压缩代码

  - ```
    删除多余的代码、注释、简化代码的写法。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css
    ```

- 利用CDN加速

  - ```
    在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径
    ```

- 删除死代码

  - ```
    将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现
    ```

- 提取公共代码

***

### 8、怎么配置单页面应用，多页应用？

单页面应用是webpack的标准模式，直接在entry中指定单页面应用的入口即可

多页应用的话，可以使用webpack的 `AutoWebPlugin`来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：

- 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表
- 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置

### 9、如何在vue项目中实现按需加载？

**Vue UI组件库的按需加载** 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。

不过很多组件库已经提供了现成的解决方案，如Element出品的`babel-plugin-component`和AntDesign出品的`babel-plugin-import` 安装以上插件后，在`.babelrc`配置中或`babel-loader`的参数中进行设置，即可实现组件按需加载了。

------

## 五、TypeScript

### 1.什么是TypeScrip

TypeScript 是 JavaScript 的超集，被编译成 JavaScript 代码在浏览器运行(TS不是直接在浏览器上运行)。

(有强大的类型系统)新增了类型系s统和完整的面向对象语法
使用 TS 编写的项目更健硕，且更容易扩展和维护,通俗点就是规范

------

```javascript
tsc --watch file1.ts
实时编译ts文件,可以通过使用–watch编译器选项来完成
```

### 2. TypeScript中的类型

- 内置数据类型：包括数字(number)，字符串(string)，布尔值(boolean)，无效(void)，空值(null)和未定义(undefined)，任意类型（any）,枚举(enums)，数组(arrays)和元组(tuple)。
- 用户定义的：它包括类(class)，接口(interfaces)

```
let names: string[] = ['刚刚', '订单'] //字符串数组
let names2: number[] = [1, 2]		//数字数组
let names3: Array<number> = [1, 2]//数字数组
var arr: any[] = [1, 2, 3, "a", "b", "c"];// 任意类型的数组
let txt:any=document.getElementById('id');// 任意类型
let ha:boolean
let a:number|string=111// 联合类型
let tup: [string, number] = ['刚刚', 3]//元组,规定类型，长度的数组
//剩余参数
//...args: string[]表示剩余的参数，放在了一个字符串数组中
function greet(x: number, ...args: string[]): string { // 返回一个字符串}

//设置可选参数，默认值
function buildName(firstName: string,lastName?: string,rate: number = 0.50) {}

//枚举
enum Color {
    Red = 1,//不赋值默认从0开始
    Green,
    Blue
};
var colorName: string = Color[2]; //访问第二个枚举子元素Green,key值
var c: Color = Color.Green;//访问第二个枚举子元素Green,value值
// 接口,解决对象类型注解的复用
interface Users {
    readonly name: string;//只读
    // name:string;
    // age:number;
    age?: number;//?可有可无
}
```

js数据类型：

**基本数据类型：**String、Number、Boolean、Null、Undefined、Symbol、BigInt（表示任意精度的整数）

**引用数据类型：**Object【Object是个大类，function函数、array数组、date日期...等都归属于Object】

### 3. TypeScript支持哪些面向对象术语？

TypeScript支持以下面向对象的术语：

- 模块（Modules）

- 类（Classes）

- 接口（Interfaces）:对值所具有的结构进行类型检查，约束

  ```
  // 总结：接口与接口之间叫继承，类与接口之间叫实现
  interface Ifly {
      fly()
  }
  interface ISwim {
      swim: () => void
  }
  
  interface IMy extends Ifly, ISwim { }//1.一个接口可以继承其他接口
  class Per implements Ifly {
  	fly() { }
  }
  //一个类可以实现多个接口
  class Per2 implements Ifly, ISwim {
      //实现接口中的方法
      fly() { }
      swim() { }
  }
  ```

  

- 继承（Inheritance）

- 数据类型（Data Types）

- 成员函数（Member functions）

### 3.解释TypeScript中的泛型？

泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性(类似函数封装)。由尖括号包裹<T>

泛型允许我们创建泛型类、泛型函数和泛型接口。

主要作用是创建逻辑可复用的组件。

```
function identity<T>(arg: T): T {
    return arg;
}
let output1 = identity<string>("edureka");
let output2 = identity<number>( 117 );
//泛型接口
interface IBase<T>{
    data:Array<T>,
    name:T[],
}
let UserC:IBase<number>={
    data:[1,2],
    name:[1,3]
}
//泛型类
class UserB implements IBase<number>{
    data:[1,2];
    name:[1,3]
}
//可以传入多个泛型参数
function aa2<P, K>(a: P,b:K): [P,K] {
    return [a,b]
}
aa2<number,string>(1,'a')
```

```
//泛型约束
interface Ilength{
    //接口中有一个length属性
    length:number
}
function getLength<T extends Ilength>(x:T):number{
    return  x.length//此时不知道x有没有length这个属性,所以用泛型约束
}
console.log(getLength<string>('kkk'))
// console.log(getLength<number>(123))报错，因为number没有length
```



### 4.TS的“接口（interface）”和“类型别名（type）”的区别？

​	interface 和 type 很相似,类型定义上，很多时候，用两种方式都能实现。

​	不同：

1. 默认导出方式不同

   ```
   // inerface 支持同时声明，默认导出 而type必须先声明后导出
   export default interface Config {
     name: string;
   }
   // 同一个js模块只能存在一个默认导出哦
    type Config2 = {name: string}
    export default Config2
   
   ```

2. 类型别名type不能extends和implements(class)

3. 对于联合类型、元组类型、基本类型（原始值）我们一般使用类型别名type，interface不支持。

4. type 能使用 in 关键字进行类型映射，interface不支持

   ```
   type Keys = "firstname" | "surname"
   
   type DudeType = {
     [key in Keys]: string
   }
   
   const test: DudeType = {
     firstname: "Pawel",
     surname: "Grzybek"
   }
   // 报错
   //interface DudeType {
   //  [key in keys]: string
   //}
   ```

   

### 5.never 和 void 的区别

void :表示没有返回值

```
// 函数
function warnUser(): void {
    //将函数的返回类型指定为 void，表示该函数不返回任何值
    console.log("This is my warning message");
}
```

`never` 表示那些永不存在的值类型。如总是抛出异常或者根本不会有返回值的函数的返回值类型。

- 一个必定会报错或者死循环的函数会返回这样的类型。

```
// ⚠️never
function errorNever(): never {
    throw new Error('error')
}
```

- 永远没有相交的类型

```
// ⚠️never
type CrossNever1 = 'boy' & 'girl'

// ⚠️never
type CrossNever2 = 1 & 2

// ⚠️never
type CrossNever3 = true & false
```

### 6.什么是TypeScript中的类型断言？

类型断言的工作方式类似于其他语言中的类型转换

```
//类型断言------querySelector获取id时获取到的是element类型，不能访问到src属性等
//有点像强制转换
let img = document.querySelector('#image') as HTMLImageElement
console.dir(img)

// 类型断言有两种写法:1.<类型>变量名,2.值 as 类型
function lei(num6: number | string): number {
    if ((<string>num6).length) {
        return (num6 as string).length
    } else {
        return num6.toString().length
    }
}
```

“as”是TypeScript中类型断言的附加语法。引入as语法的原因是原始语法与JSX冲突。

类型推论：

声明变量初始化赋值，函数返回值,可忽略类型注解,ts会自动添加

### 7.TypeScript中的方法重写是什么?

子类可继承父类中的方法，有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写

重写的作用在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。

方法重写的规则

- 该方法必须具有与父类相同的名称
- 该方法必须具有与父类相同的参数。
- 必须有一个IS-A关系(继承)。

### 8.tsconfig.json文件有什么作用？

> 该文件存在于Typescript项目的根目录里，其作用是指定相关选项告诉ts编译器如何编译ts文件。

***

## 六、JavaScript

### 1、原型、原型链

每一个对象都有一个`__proto__`指向 prototype，这个prototype就是原型。

**prototype可以让所有对象实例共享它所包含的属性和方法**

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的____proto____隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的____proto___中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

简单来说：一个对象为基准，访问他的某个属性时，以____proto__为连接点的往上层层查找，一直到Object.prototype为止的这个链就叫原型链



****

### 2、闭包

理解： 

​	闭包简单来说就是在函数里声明函数，子函数访问父函数中的局部变量，父函数不可以访问子函数变量(作用域，作用域链是向外不向内的)。也就是说**内部的函数存在外部作用域的引用就会导致闭包**

#### 为什么闭包不会被回收：

```
function f1() {
  var a = 0;
  function f2() {  闭包 f2，内部的函数叫做外部函数的  闭包函数
   a++
  	console.log(a);
   };
  return f2;
};

var result=f1();     //在全局作用域下创建变量result ，全局变量不会被回收
result指向的就是 f2，所以f2r始终都没有被销毁，而根据垃圾回收机制，由于在f2中有引用外层函数的变量a，因此a也一直没有被销毁

正常来说一个函数执行完毕以后，作用域就会被清理、内存也随之被收回。但是由于闭包时建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数---也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后，作用域内的值也不会被销毁。
```



作用：可以重复使用变量(加强封装性)，并且不会造成变量污染。产生私有作用域,让数据私有化。

缺点：比普通函数更占用内存，消耗内存，会产生内存泄漏

- 解决闭包的方法
  - 使用立即执行函数
  - 退出函数之前，将不使用的局部变量全部删除，使其被回收

#### 立即执行函数

- 立即执行函数定义：此类函数没有声明，在一次执行过后释放，适合做初始化工作。
- 立即执行函数和普通函数的区别：立即执行函数执行完就被释放

#### 列举出你平常使用闭包的场景？

封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化

***

### 3、内存泄漏

#### 什么是内存泄漏：

​		内存泄漏是指程序中已动态分布的堆内存由于某种原因程序未释放或无法释放，造成内存的浪费，导致程序运行速度减慢甚至系统崩溃

​		**内存泄漏简单来讲：指不再用到的内存，没有及时释放，造成内存的浪费。**


#### 什么会造成内存泄漏

- ​	意外的全局变量、未被关键字声明的变量

  - ```
    全局变量的生命周期最长，直到页面关闭，他都存活着，所以全局变量上的内存一直都不会被回收
    当全局变量使用不当，没有及时回收（手动赋值null），或者拼写错误等将某个变量挂载到全局变量时，也就发生内存泄漏了
    
    function  foo() {
        bar=2
        console.log('bar没有被声明!')
    }
    b 没被声明,会变成一个全局变量,在页面关闭之前不会被释放.使用严格模式可以避免.
    ```

- 遗忘的定时器

  - setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，所以当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器的话，那么这些定时器还是存活着的。如果多次关闭、打开，那么内存泄漏会越来越严重

-  闭包 

- 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）

```
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```

解决方案：一句话：不用了的要记得“归还”，例如：对象不用了，就将对象赋值为null。

****

### 4、垃圾回收机制

#### 垃圾回收机制

#### 什么是垃圾

​		一般来说没有被引用的对象就是垃圾

#### 垃圾回收机制概述

垃圾回收机制执行环境负责管理代码执行过程中使用的内存。垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行

概述：

垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

#### 垃圾回收策略

最常用的两种

标记清除和引用计数

**标记清除**：垃圾回收机制给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包）,之后内存中仍存在标记的变量就是要删除的变量，垃圾回收机制将这些带有标记的变量回收。

**引用计数**：引用计数是跟踪纪录每个值被引用的次数。就是变量的引用次数，被引用一次则加1，当这个引用数为0时，被视为准备回收的对象，每当过一段时间开始垃圾回收时候，就把引用数为0的回收。引用计数方法可能导致循环引用，导致内存泄漏

***

### 5、深浅拷贝

***浅拷贝***只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。

**深拷贝**会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

***赋值和浅拷贝的区别***

- 当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝是按位拷贝对象，**它会创建一个新对象**，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。

**浅拷贝，深拷贝，区别（敲黑板）:**

1. 浅拷贝就类似于简单的赋值，比如let a=1;b=a，这就实现了简单的浅拷贝，修改a的值，b也会跟着改变，复制的是a的引用地址，而并非栈里面的值。
2. 深拷贝就是b单独开辟出来了一块内存空间，无论a怎么变，跟b都没有任何关系，b不会因a变而变。
3. 基本数据类型，名字和值都会储存在栈内存中。引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值

从申请的大小方面讲：

​	栈空间比较小；

​	堆空间比较大。

从数据存储方面来说：

​	栈空间中一般存储基本数据类型，对象的地址；

​	堆空间一般存放对象本身，block的copy等，需要手动释放内存

#### 浅拷贝的实现方法

- **Object.assign()**
  - 当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。
- **Array.prototype.concat()**
  - 不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组
  - 如果该元素是个对象的引用，slice会拷贝这个对象引用到新数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生该百年，则新的和原来的数组中的这个元素也会发生改变
  - 对于字符串、数字及布尔值来所，slice会拷贝这些值到新数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另外一个数组
- **for···in只循环第一层**
- **直接用=赋值**

#### 深拷贝的 实现方式

- **JSON.parse(JSON.stingify())**

  - 不用在意嵌套，完美复制
  - JSON.stringfy(state)对象转换成字符串
  - 再用JSON.parse()把字符串转换成新的对象

  > 注意：可以转化成JSON格式的对象才能使用这种方法
  >
  > 如果对象中包含function或RegExp这些方法就不能用这种方法

  ```
   let newState = JSON.parse(JSON.stringify(state))
  ```

  

- **{...state}**

  - 对象嵌套太深，会出现问题

  > 当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝；
  >
  > 但是对象中由对象的时候，此方法在二级属性以后就是浅拷贝

  ```
   let newState = {...state}
  ```

  

- **手写递归**

  - ```
    
    //Es5深拷贝
    function deepClone(origin, target) {
       let tar = target || {}
       let toStr = Object.prototype.toString
           for (let k in origin) {
             if (origin.hasOwnProperty(k)) { //判断是不是自己的原型
                if (typeof origin[k] === 'object' && origin[k] !== null) { //判断是不是object
                 tar[k] = toStr.call(origin[k]) === '[object Array]' ? [] : {}; //判断是不是数组类
                     deepClone(origin[k], tar[k])
                 } else {
                 	//普通数据类型直接赋值
                     tar[k] = origin[k]
                 }
             }
         }
         return tar;
     }
    
    ```
  
  
  **jQuery的extend方法实现深拷贝**
  
  ```
  var array = [1,2,3,4];
  var newArray = $.extend(true,[],array); // true为深拷贝，false为浅拷贝
  ```
  
  **lodash函数库实现深拷贝：很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝**



***

### 6、this指向

我们使用this通常都是为了获取自己想要的对象

**全局作用域**中的this，this指向window对象，严格模式下为 undefined

```
this.name='xyf';
console.log(this);
等价与下面这个================
var name='xyf';
console.log(this);
//在用var 声明变量的是joy也是把变量挂载
```

**普通函数中的this:**

​				普通函数中的this指向的了Window对像

​	show作为一个普通函数调用，虽然看起来像构造函数，但是内部的this却指向的了Window对象				

```
function show(name){
	this.name=name;
}
show('xyf');
```

​       

**当this所在的函数是事件处理函数时，this是事件源**		



**构造函数中的this：**

​	构造函数中的this指向了它所实例化的对象

```
function show(name){
	this.name=name;
}
var myshow=new show('xyf');
console.log(myshow.name);  //'xyf'

```

**对象中的this:**

​		对象中的this指向了当前对象

​		当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。

​        函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。

```
    var obj={
        a:1,
        b:function(){
            console.log(this)
        }
    }
    obj.b()         //obj对象
    var fn1=obj.b
    fn1()          //Window对象
    function fn2(){
        console.log(this)
    }
    obj.c=fn2
    obj.c()         //obj对象
    obj.d={
        e:fn2,
        a:2
    }
    obj.d.e()      //obj.d对象

```

​	

```
var obj = {
    say: function () {
        var f1 = function () {
            console.log(this); // window, f1调用时,没有宿主对象,默认是window
        };
        f1();
    }
}
obj.say()
```

**嵌套自执行函数：**

​			this指向了全局对象Window

```
var person={
	name='origin',
	setName:function(name){
		(function(name){
			this.name=name;
		})(name);
	},
	getName:function(){
		return this.name;
	}
}
person.setName('xyf');
console.log(person.getName()) //'origin'

```

**箭头函数**是没有this的，this指向箭头函数的调用者查找

### call，apply和bind(改变this指向)的区别。

 1、相同点：三个函数都可以改变函数里的 this

 2、不同点（区别）：

​    1）、从改变this指向的角度：

​         call 和 apply 表达的意思是一样的，只是临时改变一次；call接收的是用逗号隔开的若干个参数，而apply接收的是一个由若干个参数所组成的数组；**一个函数跟上了apply/call ，那么这个函数就立即执行，bind不会执行**

​         bind：永久绑定。

​    2）、从调用bind和调用call和apply的角度

​         调用call函数,就是在调用原函数本身

​        bind会返回一个新的函数(里面的this就是绑定的对象)

​		bind跟call一样接收的是用逗号隔开的若干个参数

​		bind可以分离参数,bind接受一部分参数，返回的新函数接受一部分参数



***

### 7、Promise

Promise，他是一个对象，是用来处理异步操作的,用来解决回调地狱问题



Promise对象（异步操作）有**三种状态**：

​       Pending：进行中

​       Resolved（Fulfilled）：已完成（成功）

​       Rejected：已失败



以上三种状态的改变不受外界的影响，只由异步操作本身影响。

​     状态变化有两种情况：

​     1）、由pending 变成  Resolved

​     2）、由pending 变成  Rejected



构造函数Promise的参数是个回调函数，回调函数的参数有两个：resolve，reject

​    resolve：是异步操作成功后，调用函数

​    reject：是异步操作失败后，调用的函数



```
let promise = new Promise(function(resolve, reject) {
    setTimeout(()=>{
        if(false) {
            resolve('ok')
        } else {
            reject({err: -1, msg: '错误发生了'})
        }
    }, 1000)
})

promise.then(res=>{
    console.log(res)
}).catch(err=>{
    console.log(err)
}).finally(()=>{
    console.log('总会执行')
})

```

***

### 8、async、await

1）、 await只能写在async修饰的函数里。

2）、await是等待的意思，await修饰的代码会等待。在函数里，碰到await修饰的代码时，await朝后的代码都会等待。 等到函数外面的代码执行完毕后，再执行await里的代码。

3）、一般来说：await后面接一个Proimse对象，或者返回Promise对象的函数。

​          await 修饰函数后，那么，返回值变成了Promise对象中resolve的参数



```
async function fn() {

​    console.log("await前")

​    // await 修饰的 Promise对象的返回值是 resolve的参数，不用再写then了。

​    let res =  await new Promise((resolve, reject) => {

​        setTimeout(function () {

​            resolve("hhhh");

​        }, 1000)

​    })

​    console.log("await后:"+res)

}

fn()

console.log('虽然在后面，但是我先执行');
```



***

### 9、继承

 ES5没有类，所以函数即是类，类的首字母大写

- #### 原型链继承

 **核心：**子类将其原型对象指向父类的实例，根据原型链就可以使用到父类的方法和属性

本质： 是改变 构造函数的.prototype的指向

```
      // 父类
      function Parent() {
        this.name = ["父类"];
        this.introduce = function () {
          console.log("my name is" + this.name);
        };
      }
      // 子类
      function Child() {
        this.childname = ["子类"];
      }

      // 核心代码：
      Child.prototype = new Parent();
      var child1 = new Child();
      child1.name[0] = "child1唱歌";
      var child2 = new Child();
      child2.name[0] = "child2跳舞";
      console.log(child1.name); // child2跳舞
      console.log(child2.name); // child2跳舞
```

缺点:  

1. 所有新实例都共用父类的属性，如果一个实例修改了原型会影响其它的实例。只能继承一个。

2. 无法向父类传参

- #### 构造函数继承

  ​     **核心：**在子类的构造函数中，执行父类的构造函数，通过call改变父类中this的指向

  ```
          // 父类
          function Parent(name) {
            this.name = ["父类", name];
            this.introduce = function () {
              console.log("父类上的introduce方法", name);
            };
          }
          Parent.prototype.sayhi = function () {
            console.log("父类原型上的sayhi方法");
          };
          // 子类
          function Child(name, like) {
            this.childname = ["子类"];
            Parent.call(this, name, like);
          }
  
          var child1 = new Child("小红", "apple");
          child1.introduce();
          child1.sayhi(); //报错
  ```

  缺点: 可以继承到父类上的属性和方法，但是继承不到父类原型上的属性和方法

- #### 原型链加构造函数继承(组合继承)

```
        function Parent(name) {
          this.name = [name];
          this.introduce = function () {
            console.log("父类上的introduce方法");
          };
        }
        Parent.prototype.sayhi = function () {
          console.log("父类原型上的sayhi方法");
        };
        // 子类
        function Child(name, like) {
          this.childname = ["子类"];
          Parent.call(this, name, like); // 第二次调用Parent
        }

        Child.prototype = new Parent(); // 第一次调用Parent

        var child1 = new Child("小红", "apple");
        var child2 = new Child("小明", "orange");
        console.log(child1.name); // 小红
        console.log(child2.name); // 小明
```

​    缺点: 第一次调用Parent(),在Child.prototype写入了父类的name和introduce属性和方法，

​    第二次再调用Parent（）， 给实例child1又写入了name和introduce属性和方法。

​    实例child1上的name和introduce屏蔽了原型对象Parent.prototype的两个同名属性，

​    所以组合模式的缺点就在使用子类创建实例对象的时候，其原型中会存在两份相同的属性和方法。会比较耗内存

- #### 寄生组合式继承

完美解决原型链加构造函数继承的缺点

```
     // 父类
        function Parent() {
          this.name = ["父类"];
          this.introduce = function () {
            console.log("父类上的introduce方法");
          };
        }
        Parent.prototype.sayhi = function () {
          console.log("父类原型上的sayhi方法");
        };
        // 子类
        function Child() {
          this.childname = ["子类"];
          Parent.call(this); // 核心代码
        }
        Child.prototype = Object.create(Parent.prototype); // 核心代码，利用一个空对象作为中介、将父类原型直接赋值给空对象构造函数的原型

        const child1 = new Child();
        const child2 = new Child();
        child1.name[0] = "child1";
        child2.name[0] = "child2";
        console.log(child1);
        console.log(child1.name);
        console.log(child2.name);
```



- #### ES6 通过 class 定义一个类，再用 extends 进行继承

   通过 super 继承父类的属性或方法，底层类似寄生组合式继承

   ```
         class Parent {
           constructor(name, age) {
             this.name = name;
             this.age = age;
           }
           drink() {
             console.log("喝水");
           }
         }
         class Per extends Parent {
           constructor(name, age, sex) {
             super(name, age);
             this.sex = sex;
           }
           drink() {
             super.drink();
           }
         }
         const p = new Per("Rory", 22, "男");
         console.log(p);
   ```

- #### 区别

ES5 的继承，实质是先创造子类的实例对象，然后将再将父类的方法添加到 this 上。

ES6 的继承，先创造父类的实例对象（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。

```
super 表示父类的构造函数，用来创建父类的 this。在子类构造函数中，调用super后，才可使用this关键字，否则报错。

super 指向父类的原型即可以访问到原型上的方法和属性,也就是指向它父类的原型对象
如果用在静态方法之中，super关键字指代父类的实例，而不是父类的原型对象
```



****

### 字面量

##### 1、什么是字面量

字面量是用于表达源码中一个固定值的表示法

##### 2、常用字面量

```js
var a = {
	id:0,
	name:"张三"
}

var a = [1,2,3]

var a = "helloworld"

var b = function (){
    console.log('你好')
}
```





***

### 工厂函数

##### 1、什么是工厂函数

```
在ES5中没有类的概念，就只能利用函数模拟类。
```

工厂函数就是指这些内建函数都是类对象，当你调用他们时，实际上就是创建了一个类实例。利用一个类，创建了一个对象再返回一个对象。

简单说：工厂函数是专门创建对象的函数。作用: 降低代码冗余度 (封装了个方法减少重复工作)

```js
function fnc (name,age){
	let obj = new Object()
	obj.name = name
	obj.age = age
	obj.sayAge = function (){
		alert(`我今年${this.age}`) // this指向引用对象本身
	}
	return obj
}

let people = fnc(‘张三’，15)
console.log(people.name) //张三
people.sayAge() //我今年15
```



##### 2、缺点：

每次新建的时候都需要在内部创建一个对象，然后进行一系列操作，最后返回。也就是说创建十次，那么就会创建十次全新的对象，然后返回并赋值，且他们之间是没有关系的，没有办法解决对象的识别问题，无法认出对象所调用的属性、方法来自哪个函数。这时候构造函数就出现了，通过new 多个实例对象

***

###  构造函数

##### 1、构造函数有什么用

构造函数和工厂函数很像 ，也是用于创建对象的。只是没有了创建对象和return，并且都用this添加属性

##### 2、构造函数的特点

- 构造函数的首字母必须大写，用来区分普通函数
- 构造函数必须用new 来生成实例化对象
- 内部使用的this对象，来指向即将要生成的实例对象

##### **3、构造函数与工厂函数之间差异：**

1. 工厂函数需要创建对象，以及必须有返回值
2. 构造函数可以通过继承扩展代码

### **new做了什么?**

```javascript
// 定义的new方法
let newMethod = function (Dog, ...rest) {
  // 1. 以构造函数的 prototype 属性为原型，创建新对象；
    或者 创建空对象，设置新对象的__proto__属性指向构造函数的prototype对象
  let myDog = Object.create(Dog.prototype);
  // 2. 通过apply改变构造函数this指向和传递参数执行
  Dog.apply(myDog, rest);
  // 3. 返回第一步的对象
  return myDog;
};
```

new 其实是一种继承的方式， 通过new，实例与构造函数通过原型链连接了起来出来，所以实例能访问到构造函数的属性

### 什么是 requestAnimationFrame？

requestAnimationFrame常用来执行动画效果。

实现动画效果的方法比较多，Javascript 中可以通过定时器 setInterval来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是**请求动画帧。**

 

二、原理和优势

- **屏幕刷新频率：**屏幕每秒出现图像的次数。普通笔记本为60Hz

- **动画原理：**计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。

- **setTimeout：**通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：1、settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；2、settimeout的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。

- **requestAnimationFrame：**优势：由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿。 

- **CPU节能：**使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。

- **函数节流*****：***在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。 

  - ```javascript
        <script>
          var e = document.getElementById("e");
          var flag = true;
          var left = 0;
    
          function render() {
            if (flag == true) {
              if (left >= 100) {
                flag = false;
              }
              e.style.left = ` ${(left++)}px`;
            } else {
              if (left <= 0) {
                flag = true;
              }
              e.style.left = ` ${(left--)}px`;
            }
          }
          //setInterval效果
          // setInterval(function(){
          //     render()
          // },1000/60)
    
          //requestAnimationFrame效果
    
          (function animloop() {
            render();
            rafId = requestAnimationFrame(animloop);
            //如果left等于50 停止动画
            // if(left == 50){
            //     cancelAnimationFrame(rafId)
            // }
        })();
        </script>
    ```

    

### 10、事件流

`事件流`：指从页面中接收事件的顺序（*事件传播的过程*）

`事件冒泡`：IE的事件流叫 事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。自下而上。

`事件捕获`：是不太具体的节点先接收到事件，而最具体的节点应该最后接收到事件。自上而下。

![](https://s2.51cto.com/images/blog/202101/13/51d3d76d93c2440343ad16cff6282703.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

(DOM事件流)事件的触发包括三个阶段

1. 捕获阶段（Capture Phase）：document 往事件触发地点，捕获前进，遇到相同注册事件立即触发执行
2. 目标阶段（Target Phase）：到达事件位置，触发事件（如果该处既注册了冒泡事件，也注册了捕获事件，按照注册顺序执行）
3. 冒泡阶段（Bubbling Phase）：事件触发地点往 document 方向，冒泡前进，遇到相同注册事件立即触发



**event.stopPropagation( )**阻止冒泡

**return false 阻止默认冒泡和默认事件**

**event.preventDefault( )阻止默认事件**



***

### 11、事件委托

#### 什么是事件委托

事件委托指的是子孙元素的事件绑定，完全交给其上级父元素或祖先元素绑定

事件委托的原理用到的就是 目标元素 和 事件冒泡，把事件注册到父元素或父级以上的元素上，等待 子元素事件冒泡，并且在父元素或父级以上的元素注册的事件中能够 通过事件对象.target判断是哪个子元素，从而做相应处理。

#### 为什么要用事件委托

首先有个问题，如果你想给同一个dom元素注册多个同类型事件，你会发现通过普通直接绑定无法实现，绑定多个事件只会出发最后一个绑定的事件

添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能

**优点**：

1.大量减少内存占用，减少事件注册。

2.新增元素实现动态绑定事件(可以代理新动态添加的元素的事件)

#### **事件委托的原理：**

事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？

就是事件从最深的节点开始，然后逐步向上传播事件，

举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。

#### 适合用事件委托的事件：

click，mousedown，mouseup，keydown，keyup，keypress。



事件捕获：当一个事件出发之后，从window对象触发，不断经过下级节点，

 直到目标节点。在时间到达目标节点之前的这个过程就是捕获过程，所有经过的节点，

都会触发相对应的事件。

 事件冒泡：和捕获过程相反，沿着捕获的路线原路返回，所有经过的节点时间都会被触发

默认false，即冒泡事件，true则为捕获事件；

#### 值得注意的是：

使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。

事件冒泡的过程也需要耗时，越靠近顶层，事件的”1   事件传播链”越长，也就越耗时。

如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。

***

### 12、创建、克隆、删除节点

```
//获取父节点
var ul = document.querySelector('ul');
// 创建子节点
var li = document.createElement('li');
//添加到子元素数组的末尾
ul.appendChild(li);

// insertBefore() 添加到指定元素的前面
ul.insertBefore(li, ul.children[1]);
        
ul.removeChild(ul.children[0]);


// 克隆节点
// cloneNode()括号里面为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
// cloneNode(true) 括号里为true 深拷贝 复制标签复制里面的内容
var li1 = ul.children[0].cloneNode(true);
var li2 = ul.children[1].cloneNode();
ul.appendChild(li1);
ul.appendChild(li2);
console.log(ul);



jq

append()
appendTo()
prepend()
prependTo()
remove() - 内容节点全部删除
empty() - 内容清空，保留自身节点
clone() 
```



***

### 13、数组扁平化

数组扁平化是指将一个多维数组变为一维数组

```
 		//调用 ES6 中的 flat 方法
        console.log([1, [2, 3, [4, 5, [6, 7]]]].flat(Infinity))
```

```
		//toString & split
        function flatten1(arr) {
            return arr.toString().split(',').map(function (item) {
                return Number(item);
            })
        }
        //join & split
        function flatten2(arr) {
            return arr.join(',').split(',').map(function (item) {
                return parseInt(item);
            })
        }
```

```
		//reduce
        function flatten3(arr) {
            return arr.reduce((result, item) => {
               	 return result.concat(Array.isArray(item) ? flatten3(item) : 				item);
            }, []);
        }
```

```
		//扩展运算符
        function flatten4(arr) {
            while (arr.some(item => Array.isArray(item))) {
                arr = [].concat(...arr);
            }
            return arr;
        }
        let arr = [1, '2', [3, 4],
            [5, [6, 7]]
        ]
        console.log(flatten4(arr))
```

```
 		 //普通递归
        let result = []
        let flatten = function (arr) {
            for (let i = 0; i < arr.length; i++) {
                let item = arr[i]
                if (Array.isArray(arr[i])) {
                    flatten(item)
                } else {
                    result.push(item)
                }
            }
            return result
        }
```



***

### 14、数组去重

- new Set(arr)

```
		// Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在			Set中，没有重复的key。
		let aa = [1, 2, 2, 4, 9, 6, 7, 5, 2, 3, 5, 6, 5]
        function lyf(arr) {
            return Array.from(new Set(arr)) // 利用Array.from将Set结构转换成数组
        }
        console.log(lyf(aa))
```



- Map数据结构去重

- [...new Set(arr)]

- 双重for循环加splice

  - ```
     //双重for循环
            function lyf2(arr) {
                for (var i = 0; i < arr.length; i++) {
                    for (var j = i + 1; j < arr.length; j++) {
                        if (arr[i] == arr[j]) {
                            //如果第一个等于第二个，splice方法删除第二个
                            arr.splice(j, 1);
                            j--;
                        }
                    }
                }
                return arr;
            }
    ```
    

- indexOf去重

  - ```
    		//数组去重
            let aa = [1, 2, 2, 4, 9, 6, 7, 5, 2, 3, 5, 6, 5]
            let newaa = []
            // includes/indexOf同理
            aa.forEach(i => {
                if (!newaa.includes(i)) {
                    newaa.push(i)
                }
            })
            console.log('结果=>', newaa);
    ```






### 注意：forEach()、for....in、for....of

- forEach()

  - ```
    forEach()方法对数组中的每个元素执行一次给定的函数
    参数：
    	callback===>为数组中每个元素执行的函数，该函数接收一至三个参数
    		currentValue===>数组中正在处理的当前元素
    		index(可选)===>数组中正在处理的当前元素的索引
    		array(可选)===>forEach()方法正在操作的数组
    返回值undefined
    
    ```

  - ```
    const array1 = ['a', 'b', 'c'];
    
    array1.forEach(element => console.log(element));
    
    ```

    

- for...in

  - ```
    for..in迭代的是对象的键的列表
    ```

  - ```
    let list = [4, 5, 6];
    for (let i in list) {
        console.log(i); // "0", "1", "2",
    }
    ```
    
    ```
    let obj2={
        a:'111',
        b:'111',
    }
    for (let i in obj2) {
        console.log(i); // "a", "b"
    }
    ```
    
    

- for...of

  ​    	
  
  - ```
    for..of则迭代对象的键对应的值， for..of关注于迭代对象的值
    ```
  
  - ```
    let list = [4, 5, 6];
    for (let i of list) {
        console.log(i); // "4", "5", "6"
    }
    ```
    
    ```
    let obj2={
        a:'111',
        b:'111',
    }
    for (let i of obj2) {
        console.log(i); // 报错
    }
    ```

1. for..of和for..in均可迭代一个列表；但是用于迭代的值却不同
2. for..in迭代的是对象的键的列表，而for..of则迭代对象的键对应的值
3. for..in可以操作任何对象,但是 for..of关注于迭代对象的值。如内置对象Map和Set、Array已经实现了Symbol.iterator方法
4. 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用

#### Set、Map

- **Set**

  - ```
    Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
    
    NaN和undefined都可以被储存在Set中
    ```

  - ```
    let mySet = new Set()
    
    Array.from(mySet)
    mySet.size==>size为长度，没有length
    mySet.add==>尾部添加
    mySet.clear()==>移除Set对象内的所有元素
    mySet.delete(value)==>移除Set中与这个值相等的元素
    mySet.has(value)==>返回一个布尔值，表示该值在Set中存在与否
    mySet.keys()===>返回一个新的对象，包含Set对象中的按插入顺序的排列的所有的元素值
    
    去除字符串里面的重复字符：
    [...new Set('ababbc')].join('')
    或者 Array.from(new Set('ababbc'))
    ```
    
    ```
    Array.from()方法从类似数组或可迭代对象(如：将Set/Map结构的数据转换为真数组)创建一个新的(浅拷贝)的数组实例
    只要是部署了Iterator（遍历器,迭代）接口的数据结构，Array.from都能将其转为数组。
    
    let arr = ['aaa', 'ccc', 6, 8]
    console.log(Array.from(arr, function (e) {
        console.log(e) //  'aaa', 'ccc', 6, 8
        return e
    })) //  ['aaa', 'ccc', 6, 8]
    
    console.log(Array.from('hello world!'));
    ```
    
    

- **Map**

  - ```
     Map数据结构，类似于对象，也是键值对的集合，
     但是“键”的范围，不限于字符串，各种类型的值(包括对象)都可以当作键，
     Object结构提供了“字符串——值”的对应，Map结构提供了“值——值”的对应，
     是一种更完善的Hash结构实现，如果你需要"键值对"的数据结构，Map比Object更合适
    ```

  - ```
    let map = new Map()
    map.set('a', 111)
        .set({ n: 1 }, 222)
    map.delete('a')
    console.log(map, map.get('a'), map.has('a'), Array.from(map))
    
    Map.clear()===>移除Map对象的所有键/值对
    Map.delete(key)===>如果Map对象中存在该元素，则移除它并返回true;如果该元素不存在则返回false
    Map.get(key)===>返回键对应的值，如果不存在，则返回undefined
    Map，has（key）===>返回一个布尔值，表示Map实例是否包含键对应的值
    Map.keys()===>返回一个数组对象，按插入顺序包含Map对象中每个元素的键
    Map.set(key,value)===>设置Map对象中键的值。返回该Map对象
    Map.values()==>包含Map对象中每个元素的值
    ```
    
  - ```
    // 对象转为 Map
    let obj = {"a":1, "b":2}; //Object.entries将对象转化为二维数组
    console.log(new Map(Object.entries(obj)))
    ```
    

***

### 15、字符串api

1、str.charAt(index); 返回子字符串，index为字符串下标，index取值范围[0,str.length-1]



2、str.charCodeAt(index); 返回子字符串的unicode编码，index取值范围同上



3、String.fromCharCode(num1,num2,...,numN); 根据unicode编码返回字符串



4、str.indexOf(searchString,startIndex);  返回子字符串第一次出现的位置，从startIndex开始查找，找不到时返回-1



5、str.lastIndexOf(searchString,startIndex);  从由往左找子字符串，找不到时返回-1



6、字符串之间的比较：比较第一个字符的unicode编码值，第一个字符要是相同，就比较第二个，依次往下

　　'10000' < '2'  1的unicode值比2的unicode值小  true

　　'10000' > 2   转成数字比较  true

 

7、截取字符串

　　str.substring(start,end);  两个参数都为正数，返回值：[start,end) 也就是说返回从start到end-1的字符

　　str.slice(start,end);  两个参数可正可负，负值代表从右截取，返回值：[start,end) 也就是说返回从start到end-1的字符

　　不建议用：str.substr(start,length);  start参数可正可负，负数代表从右截取

　　除了 slice() 和 substr() 方法里的负值是代表从右截取，其他方法里的负值一律作为0处理



8、字符串分割成数组

　　str.split(separator,limit);  参数1指定字符串或正则，参照2指定数组的最大长度

　　例：str.split("");  每个字符都被分割  ['','','','']

　　　　str.split();   整个字符串放到数组里  ['']



9、str.replace(rgExp/substr,replaceText)  返回替换后的字符串



10、str.match(rgExp);  正则匹配

### [16、数组api](https://blog.csdn.net/qq_41560520/article/details/116792764?spm=1001.2014.3001.5502)

### 17、冻结对象

可以使用Object.freeze()方法来 **冻结变量**，防止对象被修改 ，如：

```
浅冻结
const obj = {
  name:"1024kb"
}
Object.freeze(obj)
// 此时对象obj被冻结，返回被冻结的对象

Object.isFrozen(obj) // true 判断一个对象是否被冻结

如何冻结深层对象？ 递归

解冻：在浏览器规范中这个是不可逆的。只能通过克隆一个具有相同属性的新对象, 通过修改新对象的属性来达到目的
```

需要注意的是，被冻结后的对象不仅仅是不能修改值，同时也

1. 不能向这个对象添加新的属性
2. 不能修改其已有属性的值
3. 不能删除已有属性
4. 不能修改该对象已有属性的可枚举性、可配置性、可写性
5. 原型也不能被修改，无法进行更新响应



***

## 七、ES6新特性

- let、const

- ES6 模块化

  ```js
  // 抛出
  export default xxx  或者  
  export xxx
  
  // 引入
  import xxx from 'xxx.js'
  ```

  

- 箭头函数

- 展开运算符，解构赋值

- Set、Map、Symbol

- Promise

- async/await

- Iterator 和 for...of 循环

- class继承

- array.from

- 数组新增方法

  1. Array.from()

  2. find()、findLast()  用于找出第一个符合条件的数组成员。**`findLast()`和`findLastIndex()`从数组结尾开始**

  3. findIndex()、findLastIndex() 返回第一个符合条件的数组成员的位置

  4. includes()

  5. flat() ：数组的成员有时还是数组，`Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。默认拉平一层。数组扁平化

     ```
     [1, 2, [3, [4, 5]]].flat()
     // [1, 2, 3, [4, 5]]
     
     [1, 2, [3, [4, 5]]].flat(2)
     // [1, 2, 3, 4, 5]
     ```

     

- 对象新增方法
  1. `Object.is('foo', 'foo')`  比较两个对象是否相等
  2. `Object.assign()`方法用于对象的合并
  3. Object.setPrototypeOf`方法的作用与`__proto__`相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。`
  4. Object.getPrototypeOf `该方法与`Object.setPrototypeOf`方法配套，用于读取一个对象的原型对象。
  5. Object.keys() 、Object.values()
  6. Object.entries()`方法返回一个数组，成员是参数对象自身的键值对数组。

```
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
```

​		7. 对象实例有一个`hasOwnProperty()`方法，可以判断某个属性是否为原生属性。ES2022 在`Object`对象上面新增了一个静态方法`Object.hasOwn()`，也可以判断是否为自身的属性。

## 八、HTTP

### 1、跨域

#### 跨域的解决方式

**什么是跨域**

不同域之间进行相互资源请求，即进行不同的域名之下的资源调用

**为什么会出现跨域**

浏览器在解析JavaScript处于安全方面的考虑，只允许在同域名下页面进行相互资源的请求调用，不允许调用其他域名下的页面的请求对象，简单的理解就是javascript同源策略的限制

##### 一、JSONP

- **JSONP原理**

  - ```
    浏览器的同源策略把跨域请求都禁止了，但是页面中的 <script><img><iframe>标签是例外，不受同源策略限制。
    Jsonp 就是利用 <script> 标签跨域特性进行跨域数据访问。
    JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。
    ```

- **JSONP和AJAX对比**

  - JSONP和AJAX相同，都是客户端向服务端发送请求，从服务端获取数据的方式。但AJAX属于同源策略，JSON属于非同源策略（跨域请求）

- **JSONP优缺点**

  - J优点：兼容性好，可用于解决主流浏览器的跨域数据访问的问题
  - 缺点：仅支持get方法具有局限性

- **JSONP流程**

  - 声明一个回调函数，其函数名当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回data）
  - 创建一个script标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址向服务器传递该函数名（可以通过问号传参 :?callback=fn）
  - 服务器接收到请求后，需要进行特殊的处理，把传递进来的函数名和他需要给你的数据拼接成一个字符串，例如，传递进去的函数名是fn，它准备好的数据是fn（[])
  - 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（fn）,对返回的数据进行操作
  - ![image-20200717084052876](C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20200717084052876.png)

  

##### 二、CORS

- CORS原理
  - 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者俩说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多处一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信
  - CORS要求浏览器和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成
  
- CORS优缺点
  - 优点：功能更加强大支持各种HTTP Method
  - 缺点：兼容性不如JSONP
  
  1. ##### 本地代理
  
  ```
  在webpack.config.js内的devServer下
  "proxy": { 
  	"/api": { 
  				"target": "http://127.0.0.1:8988/", 
  				"changeOrigin": true,
                  "pathRewrite": { "^/api" : "" } 
               } 
        } 
  ```
  
  
  
  2. ##### nodejs中间件，其他后台语言也可以设置
  
  ```
  1.PHP后台：
  
  response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); // 若有端口需写全（协议+域名+端口）
  
  response.setHeader("Access-Control-Allow-Credentials", "true");
  ```
  
  
  
  ```
   2. nodejs在全局中间件设置respones header
    app.use(function(req, res, next){
          // 跨域处理
  		res.header("Access-Control-Allow-Origin", "*");//设置允许跨域的域名，*代表允许任意域名跨域
  		res.header("Access-Control-Allow-Headers", "X-Requested-With");//允许的header类型
  		res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");//跨域允许的请求方式
  		res.header("X-Powered-By", ' 3.2.1');
  		res.header("Content-Type", "application/json;charset=utf-8");
          next();// 执行下一个路由
     });
     
  如果是koa框架
  const cors = require('koa-cors');
  app.use(cors({
      origin: '*',
      exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'],
      maxAge: ,
      credentials: true,  //cookie
      allowMethods: ['GET', 'POST', 'DELETE', 'OPTIONS', 'PUT'],
      allowHeaders: ['Content-Type', 'Authorization', 'Accept']
  }));
  ```
  
  ##### nginx代理
  
  首先安装Homebrew，再安装Nginx
  
  ```
  在nginx.conf中配置，在 server 下配置：
   
   server { 
   		listen 80; 
   		server_name localhost; 
   		location / {  第一个location用于指向静态资源位置 root:目录, index:入口文件
   				root /Users/abc/dist/; 
   				index index.html index.htm; 
   			} 
   		location /api/ { ,第二个location用于进行api的跨域指向
          		proxy_pass https://xxx.xxx.xxx/req/;
              } 
   }
   
  nginx还可以用于实现多入口
  server { 
  		listen 80; 
  		server_name www.aaa.com; 
  		location /api/ { 
  				proxy_pass http://localhost:7001; 
  			} 
  } 
  server { 
  		listen 80; 
  		server_name www.bbb.com; 
  		location /api/ { 
  				proxy_pass http://localhost:7002; 
  			} 
  }
  
  ```
  
  

##### 三、WebSocket

WebScoket是HTML5的一个持久化的协议，它实现了浏览器与服务器的双向数据传输，同时也是跨域的一种解决方案。WebScoket在建立连接时需要借助HTTP协议来完成一部分握手，连接建立好了之后client与server之间的双向通信就与HTTP无关了

原生WebScoketAPI使用不方便，选择使用Scoket.io（封装了WebScoket接口）,它

提供了更简单、灵活的接口，也支持webScoket的浏览器提供了向下兼容

```
//--------------------------------------前端代码：------------------------------
<div>user input：<input type="text">
</div><script src="./socket.io.js"></script>
<script>
var socket =io('http://www.domain2.com:8080');
// 连接成功处理
socket.on('connect', function(){   
    // 监听服务端消息
    socket.on('message',function(msg){
        console.log('data from server: ---> '+ msg);
    });
 
    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.');     
    });
});
    document.getElementsByTagName('input')[0].onblur = function() {
        socket.send(this.value);
    };
</script>
 
 原生:
      function WebSocketTest() {
        if ("WebSocket" in window) {
          alert("您的浏览器支持 WebSocket!");

          // 打开一个 web socket
          var ws = new WebSocket("ws://localhost:9998/echo");

          ws.onopen = function () {
            // Web Socket 已连接上，使用 send() 方法发送数据
            ws.send("发送数据");
            console.log('连接服务器成功了')
          };

          ws.onmessage = function (evt) {
            var msg = evt.data;
            console.log('接收到从服务端发来数据',msg)
          };

          ws.onclose = function () {
            // 关闭 websocket
            console.log('连接服务器失败了')
          };
        } else {
          // 浏览器不支持 WebSocket
          alert("您的浏览器不支持 WebSocket!");
        }
      }
    </script>
 
 
//---------------------------------------Nodejs socket后台：---------------------------
var http = require('http');
var socket =require('socket.io');
// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {'Content-type': 'text/html'});
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
// 监听socket连接
socket.listen(server).on('connection', function(client) {
    
// 接收信息
    client.on('message', function(msg) {        
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);    
    });
    
// 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.');     
    });
});

// 或
//npm i ws -s
const WebSocket = require('ws')
//创建WebSocket服务器对象，绑定端口9998
const wss = new WebSocket.Server({
    port: 9998
})
module.exports.listen = () => {
    //对客户端的连接事件进行监听
    wss.on('connection', client => {//client代表客户端的连接socket对象
        console.log('有客户端连接成功了...')
        //对客户端的连接对象进行message事件监听
        client.on('message', msg => {
            console.log('客户端发送数据给服务端了:' + msg)
            // //由服务端向客户端发送数据
            // client.send(msg)
            wss.clients.forEach(client => {
                client.send(msg)//全部客户端更新
            })
        })
    })
}
```

##### 四、postMessage

window.postMessage() 方法允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不用管是否跨域。

这项技术称为“跨文档消息传递”，又称为“窗口间消息传递”或者“跨域消息传递”。

```
基本原理是通过postMessage来发送跨文档信息，使用message来进行监听，当收到跨文档信息后，会触发message事件
```

```
  <body>
    <button onclick="openB()">open B</button>
    <script>
      // A.html
      // A打开B并且发送数据给B
      const msg = "A传过去的";
      const open = window.open("http://127.0.0.1:5500/postMessage-B.html", "B");
      function openB() {
        open.postMessage(msg, "http://127.0.0.1:5500");// 指定接收消息事件的窗口
      }

      // A打开B，B发送数据给A
      window.addEventListener("message", (e) => {
        if (e.origin === "http://127.0.0.1:5500") {
          console.log(e.data); // B传过去的
        }
      });
    </script>
  </body>
```

```
  <body>
    <script>
      // B.html
      // B发送数据给A
      const opener = window.opener;
      opener.postMessage('B传过去的', "http://127.0.0.1:5500");
      // URI必须是opener窗口所在在的URI
      // 意思就是说，如果是从 http://127.0.0.1:5500 中的某个页面将B页面打开，那么就能成功发送跨文档信息
      // 如果讲此处的URI换成"*"，就意味着任何网页打开B页面，都能收到B页面传输的信息

      // 监听A传过来的
      window.addEventListener("message", (e) => {
        console.log(e.data); // A传过去的
        console.log(e.origin); // http://127.0.0.1:5500 发送消息的文档源
        console.log(e.source); // 发送消息的window代理对象
      });

    </script>
  </body>
```



****

### 2、同源策略

####        同源策略

- 同源策略要求源相同才能进行正常的资源交互，即要求当前页面与调用资源的协议，域名、子域名、端口完全一致，其中有一方不同，就是跨域

- 在跨域问题上，域仅仅是通过“URL的首部”来识别，而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议，域名和端口必须匹配”。

- 同源策略的优点：

  - 可以保护用户隐私信息，防止身份伪造等（如读取cookie）

- 同源策略限制：

  - 同源策略限制一个资源地址加载的文档或脚本与来自另外一个资源地址的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的关键的安全机制

  - 限制内容：

    - Cookie、LocalStorage、IndexedDB等储存性内容。浏览器来说，“cookie区分域，而不区分端口“，所以cookie在相同域名不同端口号可以共享
    - 不允许进行DOM节点的操作
    - 不能进行AJAX请求

  - 同源策略的天然支持跨域请求的特性属性

    - ```
      <img src="xxx"/>
      
      <link href="xxx"/>
      
      <script src="xxx"></script>
      ```



****

### 3、三次握手四次挥手

#### 三次握手

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。防止服务器端开启一些无用的连接，增加服务器开销

三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.

*在socket编程中，客户端执行connect()时。将触发三次握手。*

> 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
>
> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
>
> 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

**1.1 为什么需要三次握手，两次不行吗？**

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

第一次握手：客户端发送网络包，服务端收到了。

这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。

这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。

这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

> **试想如果是用两次握手，则会出现下面这种情况：**

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

 **三次握手过程中可以携带数据吗？**

其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据

第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

#### 四次挥手

> 建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是连接的一端在结束它的发送后，还能从另一端接收数据。

*在socket编程中，任何一方执行close()操作即可产生挥手操作。*

当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK报文，此时**一个方向**的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有数据后，会发送一个FIN报文来关闭此方向上的连接。接收方发送ACK报文确认关闭连接。

1. 客户端发送指令告诉服务器，我要关闭连接了
2. 服务器发送报文说我已经接受到了
3. 服务器告知客户端可以关闭连接了，等待客户端的确认
4. 客户端发是一个报文给服务端，确认断开连接

通俗的说法

1）Client：我所有东西都说完了

2）Server：我已经全部听到了，但是等等我，我还没说完

3）Server：好了，我已经说完了

4）Client：好的，那我们的通信结束



**TCP/IP 中有两个具有代表性的[传输层协议](https://so.csdn.net/so/search?q=传输层协议&spm=1001.2101.3001.7020)，分别是 TCP 和 UDP。**

![](https://img-blog.csdnimg.cn/d7df0cbcf0e14108b686630c647a3700.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Lya6aOe55qESVTonJfniZs=,size_17,color_FFFFFF,t_70,g_se,x_16)

UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了，安全不可靠

***

### 4、GET、POST、PUT、DELETE

- ##### GET 方法

  - 请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：

    ```
    /test/demo_form.asp?name1=value1&name2=value2
    ```

    有关 GET 请求

    - GET 请求可被缓存
    - GET 请求保留在浏览器历史记录中
    - GET 请求可被收藏为书签
    - GET 请求不应在处理敏感数据时使用
    - GET 请求有长度限制，Http get方法提交的数据大小长度并没有限制，Http协议规范没有对URL长度进行限制的。但目前说的get长度有限制，是特定的浏览器及服务器对它的限制。
    - GET 请求只应当用于取回数据
    - 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）
    - 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！

- ##### POST 方法

  - 请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：

    ```
    POST /test/demo_form.asp HTTP/1.1
    Host: w3schools.com
    name1=value1&name2=value2
    ```

    有关 POST 请求

    - POST 请求不会被缓存
    - POST 请求不会保留在浏览器历史记录中
    - POST 不能被收藏为书签
    - POST 请求对数据长度没有要求，但一般服务器会限制
    - 发送数据无限制
    - POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。

- PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
- DELETE: 用于删除指定的资源

 GET 方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。

POST 方法是一个非幂等方法，因为调用多次，都将产生新的资源。

***

### 5、Cookie、Session、LocalStorage、SessionStorage

- cookie
  - 生命期：存放于客户端。可设置失效时间，若不设置cookie的过期时间，则有效期为浏览器窗口的会话期间，默认是关闭浏览器 后失效
  - 大小限制：4kb左右
  - 与服务器通信：始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。如果使用cookie保存过多数据会带来性能问题
  - 保存着sessionId，当进入网页时，倘若sessionId不存在、不匹配，则页面无法显示

- session

  - session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，而且成本高
  
- localStorage
  - 生命期：用于本地数据储存，保存的数据没有过期时间，除非被清除，否则永久保存
  - 大小限制：5MB左右
  - 与服务器通信：仅在浏览器中保存，不与服务器通信

- sessionStorage：
  - 生命期：仅在当前会话下有效，关闭页面或浏览器后被清除
  - 大小限制：5MB
  - 与服务器通信：仅在浏览中保存，不与服务器通信

#### cookie和session结合使用：

##### 一般有两种存储方式：

* 存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。（服务端session）
* 将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。（客服端session）
  	 

****

### 6、http缓存机制

#### http有两个缓存机制

缓存：缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。

**强缓存**：

1）强制缓存机制：当浏览器请求资源的时候，会查看缓存中的资源是否存在，并且确定该缓存的资源是否过了“保质期”，若没有超过保质期则将取得缓存中的资源进行下一步处理。<font color='red'>**客户端实现**</font>

2）实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，状态码 为 `200`；`Expires` 受限本地时间，如果修改了本地时间，那么有可能会造成缓存失败；

**协商缓存**：

1）协商缓存（对比缓存）：流览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库（电脑本地磁盘）中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据

2）协商缓存需要<font color='red'>**客户端和服务端共同实现**</font>，和强缓存一样，也有两种实现方式：

​		**Last-Modified 和 If-Modified-Since**，`Last-Modified`表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成 `Last-Modified`被修改，所以在 `HTTP / 1.1` 出现了 `ETag`

​		**ETag 和 If-None-Match**，`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag`发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。

------

HTTP 标准端口是80 ，而 HTTPS 的标准端口是443

**HTTP:**

超文本传输协议，是一个客户端和服务器端请求和应答的标准

它是基于传输层的TCP协议的应用层协议

**HTTP2**

- 二进制协议： 在HTTP1.1的头部信息是文本格式，文本的表现形式有多样性，HTTP/2的头信息和数据都变为二进制，统称为**帧**：头信息帧和数据帧

HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语意兼容的基础上，进一步减少了网络的延迟。实现了低延迟高吞吐量。HTTP2有二进制分帧，首部压缩，流量控制，多路复用，请求优先级，服务器推送等新特性。

**HTTPS:**

是HTTP的安全版

安全：HTTPS是HTTP和SSL组合而成的,在传输层使用了SSL进行加密,保证了只有拥有私钥的才能看到。可防止数据在传输过程中不被窃取、改变，确保数据的完整性

但HTTPS协议需要SSL握手，握手阶段比较费时（比HTTP慢），缓存不如HTTP高效，会增加数据开销。

区别简介：

1. http1.0:无连接,无状态,一次请求一个tcp连接
2. http1.1:持久连接,请求管道化(有一些缺陷) ,增加了host字段,缓存,断点续传
3. http2.0 : 二进制分帧(多路复用的实现基础), 多路复用,头部压缩

#### http和https的区别:

- HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
- HTTP 是不安全的，而 HTTPS 是安全的
- HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
- 在 OSI 网络模型中，HTTPS的加密是在传输层完成的,因为SSL是位于传输层的,TLS的前身是SSL,所以同理
- HTTP无需认证证书,而https需要认证证书 

### 8、http的请求报文、响应报文是什么样的？

#### 请求报文有4部分组成:

- 请求行
  - 由3部分组成，分别为：请求方法、URL、以及协议版本，之间由空格分隔
- 请求头部
  - User-Agent：产生请求的浏览器类型。
  - Accept：客户端可识别的内容类型列表。
  - Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
- 请求体
  - post put等请求携带的数据
  - 可选部分，比如GET请求就没有请求正文

#### 响应报文

- 响应行
  - 由协议版本，状态码和状态码状态码描述组成，例如`HTTP/1.1 200 OK`。
- 响应头：与请求头部类似，为响应报文添加了一些附加信息
- 响应体：服务器响应的数据



### 9、axios

- 基于promise的异步ajax请求库

- 浏览器端/node端都可以使用

- 客户端防止CSRF（网站恶意利用）

- 支持请求/响应拦截器

- 支持请求取消

- 请求/响应数据转换

- 批量发送多个请求(并发请求)

- ```
  import axios from 'axios'
  let config = {
    baseURL: '接口地址',
    timeout: 5000,
    headers: {'X-Custom-Header': 'foobar'}
  }
  
  export default axios.create(config)
  
  ```

***

#### `fetch`和`XMLHttpRequest`相比:

- 语法简洁，更加语义化
- 基于标准 Promise 实现，支持 async/await
- fetch请求默认是不带cookie的，需要设置fetch（URL，{credentials:’include’})。
- 所有版本的 IE 均不支持原生 Fetch
- fetch是原生js
- fetch 没有办法原生监测请求的进度，而 XHR 可以

### 常用状态码

- `1xx`: 接受，继续处理
- `200`: 成功，并返回数据
- `201`: 已创建
- `202`: 已接受
- `203`: 成为，但未授权
- `204`: 成功，无内容
- `205`: 成功，重置内容
- `206`: 成功，部分内容
- `301`: 永久移动，永久重定向
- `302`: 临时移动，可使用原有URI，临时重定向
- `303`:应使⽤ GET 方法
- `304`: 资源未修改，可使用缓存
- `305`: 需代理访问
- `400`: 请求语法错误，后端执行代码错误（服务器端出错）
- `401`: 要求身份认证,如token
- `403`: 拒绝请求
- `404`: 资源不存在
- `408`: 请求超时
- `500`: 服务器错误

### 10、AJAX

AJAX 是一种在**无需重新加载整个网页**的情况下，能够**部分更新网页中**的技术，前端通过与服务器进行少量数据交换，AJAX 可以使网页实现**异步**更新，传统模板渲染是更换HTML文件，(进行大量的重绘和回流)消耗性能；

优点：

​		1）最大的一点是页面无刷新，用户的体验非常好。

​		2）使用异步方式与服务器通信，具有更加迅速的响应能力。

​		3）可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本

​		4）通过局部更新页面降低网络流量，提高网络的使用效率

缺点：破坏浏览器的后退与加入收藏书签功能

ajaj的步骤:

1. 创建 XMLHttpRequest 对象

   ```
   		let xhr;
           if (window.XMLHttpRequest) {
               xhr = new XMLHttpRequest() //ie7+
           } else {
               xhr = new ActiveXObject('Microsoft.XMLHTTP')
           }
   ```

   

2. 规定请求的类型、URL 以及是否异步处理请求。

```
 xhr.open('GET', url?a=1&b=2,true); 
//　除了"GET"和"POST"之外，参数还可以是"HEAD"、"OPTIONS"、"PUT"。而由于安全风险的原因，"CONNECT"、"TRACE"、"TRACK"被禁止使用
// 第三个参数是表示是否异步发送请求的布尔值，如果不填写，默认为true，表示异步发送
 // post设置请求头
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
//为了将请求体里面的数据转换为键值对,让后端知道是post传来的数据
```

3. 发送请求

   ```
    xhr.send(null); 
   //如果是GET方法，send()方法无参数，或参数为null；
   //如果是POST方法，send()方法的参数为要发送的数据
   // xhr.send('a=1&b=2')
   ```

4. 接受服务器响应数据

```
 xhr.onreadystatechange = function () {
            console.log(xhr.responseText);//3
            // readyState仅仅是针对请求的状态码，获取资源是否成功取决于status的状态
         if (obj.readyState == 4 && (obj.status == 200 || obj.status == 304)) {
                // 0(UNSENT): 未初始化。 尚未调用open() 方法
                // 1(OPENED): 启动。 已经调用open() 方法， 但尚未调用send() 方法
                // 2(HEADERS_RECEIVED): 发送。 己经调用send() 方法， 且接收到头信息
                // 3(LOADING): 接收。 已经接收到部分响应主体信息
                // 4(DONE): 完成。 已经接收到全部响应数据， 而且已经可以在客户端使用了
                console.log(xhr.responseText);
                //responseText获取字符串；responseXML获取xml
            } else {
                alert('request was unsuccessful:' + xhr.status);
            }
        };
```

1）get请求：

get通过url传递参数

发送给后端的数据，写在地址的后面，用问号隔开。

 2）post请求：

1. 发送给后端的数据，不能跟在地址是后面，需要写在xhr.send函数的参数里。

2. 在send（）之前，需要设置请求头，即：，增加这个句代码：xhr.setRequestHeader("content-type","application/x-www-form-urlencoded"）;
3. get传输速度比post快 根据传参决定的

(post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取)

5. post传输文件大理论没有限制 get传输文件小大概7-8k ie4k左右
6. get获取数据 post上传数据

(上传的数据比较多 而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择)

get请求参数在url能看见，并且在浏览器url历史记录里面能看到



1、属性：

   1）事件属性：

onreadystatechange 此事件的触发时机，是后端响应时，触发。起始它会被触发三次。当readyState属性的值从1变到2时，开始依次触发。

   2）readyState属性：

​      该属性的意思是，前后端交互过程中，状态的变化，即进行 到了哪一步。

​      0：当XMLHttpRequest创建完备后的初始值

​      1：当调用了open函数后，准备好了，表示在open函数调用后，到send函数执行前。

​      2：后端收到了响应（接收到了请求）

​      3：后端（服务器端）处理中，正在解析响应体

​      4：后端处理完毕，即：前后端的交互完毕，响应体解析完毕， 可以正常使用

 3）status属性：

​      该属性描述的是HTTP的响应状态码；

​      表示，后端处理完毕后，后端响应的状态码

​      200：后端执行代码成功

​      400：后端执行代码错误（服务器端出错）

​      404：找不到页面

  4）responseText属性：

​      该属性，表示后端响应的内容，在hpph中，就是echo后面写的内容。

```
// 1、创建对象
let xhr = new XMLHttpRequet();

// 2、设置请求数据方式等，如果请求方式是get时，将传入的参数通过？连接再请求的地址后面，如果是post请求，则把参数放在xhr.send()的括号内
xhr.open(请求方式，请求的地址，是否异步);

// 3、通过xhr.onreadystatechange 设置回调函数
xhr.onreadystatechange = function(){
   //  xhr.readyState==4  表示请求响应的过程完毕了
   //  xhr.status==200：表示后端执行没有问题。
	if(xhr.readyState==4  && xhr.status==200){
	    // 5、接收响应
	    xhr.responseText;  // xhr.responseText 接收后端发来的响应内容
        // 然后通过响应回来的数据做出相应的操作
    }
}
// 如果是post请求则使用send()函数发送前需设置请求头
// setRequestHeader("content-type","application/x-www-form-urlencoded");
xhr.send();

```



### 11、原生图片懒加载

原生图片懒加载（设置可视区域，图片到了可视区域再加载）

图片懒加载原理是使用js监听图片元素是否进入可视窗口，进入之前，将图片链接设为假地址而真正的地址用自定义属性data-src储存起来，进入之后，将src属性值替换成真正地址；

- 第一种

  - documentElement.clientHeight===>视口高度
  - htmlElement.offsetTop===>返回当前元素相对于文档顶部的距离
  - documentElement.scrollTop==>滚动条卷去的高度

  scrollTop+clientHeigh(不变)>offsetTop(不变)。表示出现在可视区域

- 第二种

  - getBoundingClientRect（）获取元素大小及其相对于视口的位置

  - window.innerHeight==>一样获取可是高度，只是兼容性问题

  - ```
    var imgs = document.querySelectorAll('img');
    
            //用来判断bound.top<=clientHeight的函数，返回一个bool值
            function isIn(el) {
                var bound = el.getBoundingClientRect();
                var clientHeight = window.innerHeight;
                return bound.top <= clientHeight;
            } 
            //检查图片是否在可视区内，如果不在，则加载
            function check() {
                Array.from(imgs).forEach(function(el){
                    if(isIn(el)){
                        loadImg(el);
                    }
                })
            }
            function loadImg(el) {
                if(!el.src){
                    var source = el.dataset.src;
                    el.src = source;
                }
            }
            window.onload = window.onscroll = function () { //onscroll()在滚动条滚动的时候触发
                check();
            }
    ```


```
var screenTop=document.documentElement.scrollTop|| document.body.scrollTop
var winHeight=document.documentElement.clientHeight|| document.body.clientHeight
ar scrollHeight=document.documentElement.scrollHeight|| document.body.scrollHeight

console.log('结果=>',screenTop+winHeight,scrollHeight);
（screenTop+winHeight>=scrollHeight）页面滚动到底部
```



### 12、防抖和节流

##### 防抖

指触发事件后在**规定时间内**回调函数**只能执行一次**,如果在规定时间内**又**触发了该事件，则会重新开始算规定时间。
四个字总结就是**延时执行**

>通过定时器将回调函数进行延时，如果在规定时间内继续回调，发现存在之前的定时器，则将该定时器清除，并重新设置定时器。
>这里有个细节,就是后面所有的回调函数都要能访问到之前设置的定时器,这时就需要用到闭包。

#### 两种版本

应用场景：搜索功能...

```
function antiShake(fn, wait) {
            let timeOut = null;
            return args => {
                if (timeOut) clearTimeout(timeOut)
                timeOut = setTimeout(fn, wait)
            }
        }
```



##### 节流

节流就是保证一段时间内只执行一次核心代码

当持续触发事件时，在规定时间段内只能调用一次回调函数。
如果在规定时间内**又**触发了该事件，**则什么也不做,也不会重置定时器.**

```
防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次.一般不会重置定时器.
即不会if (timer) clearTimeout(timer);**(时间戳+定时器版除外)**
```

应用场景：滚动浏览器滚动条的时候，更新页面上的某些布局内容或者去调用后台的某接口查询内容。

```
// 时间戳方案
        function throttle(fn, wait) {
            var pre = Date.now();
            return function () {
                var context = this;
                var args = arguments;
                var now = Date.now();
                if (now - pre >= wait) {
                    fn.apply(context, args);
                    pre = Date.now();
                }
            }
        }
        // 定时器方案
        function throttle2(fn, wait) {
            var timer = null;
            return function () {
                var context = this;
                var args = arguments;
                if (!timer) {
                    timer = setTimeout(function () {
                        fn.apply(context, args);
                        timer = null;
                    }, wait)
                }
            }
        }
```

这两者最大的区别:是时间戳版的函数触发是在规定时间开始的时候，而定时器版的函数触发是在规定时间结束的时候



### 13、3大家族

- offset家族
   offsetHeight:   元素的可见高，height+border+padding **包含滚动条**
   offsetWidth:    元素的可见宽，width+border+padding **包含滚动条**
   offsetTop:      上边距离带有定位的父盒子的距离（重要）
   offsetLeft: 左边距离带有定位的父盒子的距离（重要）
   offsetParent:   最近的带有定位的父盒子

- scroll家族：包括溢出的不可见内容(**元素完整的高度和宽度**)
   scrollHeight:   内容高，包含padding不含border。
   scrollWidth:    内容宽，包含padding 不含border 

---
   scrollTop: document.documentELement.scrollTop || document.body.scrollTop; （重要）window.pageXOffset;
   浏览器页面被卷去的头部
   元素调用.必须具有滚动条的盒子调用。盒子本身遮挡住的子盒子内容。
   子盒子被遮挡住的头部

----
   scrollLeft:     document.documentELement.scrollLeft:  || document.body.scrollLeft: ; （重要）    window.pageYOffset;
   浏览器页面被卷去的左侧
   元素调用.必须具有滚动条的盒子调用。盒子本身遮挡住的子盒子内容。
   子盒子被遮挡住的左侧

- client家族
   clientHeight:   内容的可见高，height+padding; **不包含滚动条**
   window.innerHeight; document.body.clientHeight     可视区域的高
   clientWidth:   内容的可见宽度，width+padding; **不包含滚动条**
   window.innerWidth;  document.documentElementWidth; 可视区域的宽
   clientTop:      元素的上border宽
   clientLeft:     元素的左border宽
   clientY     调用者：event.clientY(event)（重要）
   作用：鼠标距离浏览器可视区域的距离，上
   clientX     调用者：event.clientX(event)（重要）
   作用：鼠标距离浏览器可视区域的距离，左

**client家族特殊用法：检查浏览器宽高（可视区域）兼容性写法**



```jsx
 //获取屏幕可视区域的宽高
    function client(){
        if(window.innerHeight !== undefined){
            return {
                "width": window.innerWidth,
                "height": window.innerHeight
            }
        }else if(document.compatMode === "CSS1Compat"){
            return {
                "width": document.documentElement.clientWidth,
                "height": document.documentElement.clientHeight
            }
        }else{
            return {
                "width": document.body.clientWidth,
                "height": document.body.clientHeight
            }
        }
    }
```




****

## 九、HTML+CSS

DNS解析速度是造成页面延迟加载的最大的原因

dns-prefetch 即**DNS预解析技术**让浏览器提前对域名进行解析,缩短DNS解析时间，来提高网站的访问速度，减少用户等待时间，提高用户体验



### 1、从浏览器地址栏输入url到显示页面的步骤

- 浏览器根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，建立TCP链接(三次握手)，HTTP发起请求(请求行，请求头，请求体)，关闭TCP链接(4次挥手)；
- 服务器处理请求，服务器向浏览器发送HTML、CSS、JS、图片等等资源；
- 浏览器 解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。
- 在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现js阻塞问题；所以通常建议把script放在body最后
- 根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等信息。
- 遍历渲染树绘制页面中的各元素，这期间会发生大量的一个重绘和回流

#### js阻塞

**原因是：**JavaScript是单线程，在JavaScript运行时其他的事情不能被浏览器处理

1. HTML5中提供了两个属性供<script>标签使用，目的就是为了无阻塞加载JavaScript。

```
<script src="file1.js" defer></script>
<script src="file2.js" async></script>
```

**加载流程：**当解析器遇到设置defer或者async属性的<script>元素时，它开始下载脚本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等待他下载。

**defer和async区别：**

就defer和async的区别而言，使用defer的<script>标签是按照他们排列的顺序执行的，而使用async的<script>标签是不按他们在HTML中的排列顺序执行的；

defer是立即下载但延迟执行，加载后续文档元素的过程将和脚本的加载并行进行（异步），但是脚本的执行要在所有元素解析完成之后

async是立即下载并执行，加载和渲染后续文档元素的过程将和js脚本的加载与执行并行进行（异步）

当defer和async同时存在时，会忽略defer而遵循async。且使用defer和async的脚本禁止使用document.write方法哦。

2. **利用dom方法创建一个动态的script标签**

html解析器将script当做了dom元素，而不是script标签，所以就不对其进行诸如加载、解析、运行时，停止页面中一切行为

### 让js引擎成为多线程

注意：像定时触发器线程、异步HTTP请求线程，听起来像JS的执行，但是其实归属于浏览器，而不是JS引擎（可以理解为：JS引擎自己都忙不过来，需要浏览器另开线程协助(放在事件队列中)，等待JS引擎主线程执行完，空闲了再执行）

Web Worker

**HTML5中支持了 Web Worker，它的作用就是为了解决这种阻塞的现象。当我们使用Web Worker的时候，它就会向浏览器申请一个子线程。该子线程服务于主线程，完全受主线程控制，用来单独执行一个js文件**不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

如果需要进行一些高耗时的计算时，可以单独开启一个WebWorker线程

Web Worker 有以下几个使用注意点。

（1）**同源限制**

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

（2）**DOM 限制**

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用`document`、`window`、`parent`这些对象。但是，Worker 线程可以`navigator`对象和`location`对象。

（3）**通信联系**

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

（4）**脚本限制**

Worker 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

（5）**文件限制**

Worker 线程无法读取本地文件，即不能打开本机的文件系统（`file://`），它所加载的脚本，必须来自网络。

```javascript
    <script>
        console.log("非阻塞1");
      var worker = new Worker("./webworker.js");
      worker.postMessage("主线程发送的数据");
      worker.onmessage = function (event) {
        console.log("worker进程发来的数据", event.data);
      };
      console.log("非阻塞");
    </script>
      //postMessage 用来发送消息.
      //onmessage用来接受消息.
```

```

// webworker.js
var i = 0;
function timedCount(){
    for(var j = 0, sum = 0; j < 100; j++){
        for(var i = 0; i < 100000000; i++){
            sum+=i;
        };
    };
    //将得到的sum发送回主进程
    postMessage(sum);
};
//将执行timedCount前的时间，通过postMessage发送回主进程
postMessage('Before computing, '+new Date());
timedCount();
//结束timedCount后，将结束时间发送回主进程
postMessage('After computing, ' +new Date());

self.onmessage = (event) => {
	console.log(event.data);	//主线程发送的数据
}
// Worker线程可以通过self.close自行销毁。
```

[![jb7p8S.png](https://s1.ax1x.com/2022/07/20/jb7p8S.png)](https://imgtu.com/i/jb7p8S)

进程：程序的一次执行，它占有一片独有的内存空间
线程：是进程内的一个独立执行单元，是程序执行的一个完整流程，是CPU的最小的调度单元

单线程：一个进程内有一个线程
多线程：一个进程内有多个线程

### W3C标准

是一系列标准的集合，三部分：结构化标准，表现标准，行为标准

1. 图片的alt="" 属性必须每张图片都加上
2. 每个文档必须加上DTD声明。
3. 标签之间不可错位嵌套
4. 所有的标签都使用小写。
5. JS和CSS外部引入文件必须加上类型定义
6. 标签必须配对完成,单标签必须以/关闭

***

### 2、link和@import的区别是什么

区别：

link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS

link引用CSS时，在页面载入同时加载；@import需要页面网页完全载入以后加载



link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持



link支持使用JavaScript控制DOM去改变样式；而@import不支持

***

### 3、标准盒模型、怪异盒模型

- #### 标准盒

  - 特点：一个块的总宽度= content本身width
  - 触发条件：box-sizing: context-box;

- #### 怪异(IE)盒

  - 特点：一个块的总宽度= content本身width+ margin+ padding + border
  - 触发条件：box-sizing: border-box;

****

### 4、垂直居中的方法

第一种：定位+margin

```
position：absolute；
left:0;
top:0;
rigth:0;
bottom:0;
margin:auto;
```

第二种：transfrom

```
position:relative;
left:50%;
top:50%;
transfrom:translate(-50%,-50%);
```

第二种：flex方法

```
display：flex;
justify-content:center;
align-items:center;
```



### 5、BFC：

BFC它是**块级格式化上下文。一个独立的渲染区域**，里面的子元素不会在布局上影响外面的元素（里面怎么布局都不会影响外部）

#### 布局规则

1、内部的Box会在垂直方向，一个接一个地放置

2、Box的垂直方向距离由margin决定。属于同一个BFC两个相邻的Box的margin会发生重叠（会按照最大margin值设置）

3、每个元素的margin box的左边，与包含块的 box的左边相接触

4、BFC的区域不会与float元素重叠

5、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素

6、计算BFC的高度时，浮动元素也参与计算，子元素也参与计算

#### 触发条件，**如何创建BFC?**

1、float属性不为none

2、positio为absolute或fixed

3、display：为inline-block，table-cell，flex，inline-flextable-caption

4、设置overflow，即hidden，auto，scroll

5、根元素HTML就是一个最大的带有BFC的容器

#### BFC的作用

1、自适应两栏布局

2、清除浮动，比如overflow：hidden创建BFC，区域内的子元素任何边动都是不会影响到外部元素，可以清除浮动

3、**解决外边距的塌陷问题(垂直塌陷)**

```
		a、全部都为正值，取最大者；
		b、不全是正值，则都取绝对值，然后用正值减去最大值；
		c、没有正值，则都取绝对值，然后用0减去最大值。
```
4、解决子元素加margin可能会带着父元素一起跑

### 6、清除浮动，解决高度塌陷

第一种：创建父级BFC，给父元素添加样式overflow:hidden; 

第二种：父级元素设置高度，弊端也很明显, 父元素的高度不能随子元素改变.

第三种：在浮动元素后使用一个空元素并带clear:both属性

第四种：

```
.cl:after {

        content: "";

        display: block;

        overflow:hidden;

        visibility:hidden;

        height: 0;

        clear: both;

    }
```

### 去除div中img元素的白边

1. 将img的display设置为block
2. 父元素中添加font-size:0;

#### margin-top对父级元素产生作用

1. 为父元素设置内边距padding。来代替给子元素设置margin-top 
2. 为父元素设置边框border。 
3. 为父元素设置 `overflow: hidden` 。

### BOM,DOM

- BOM---浏览器对象模型,核心是Window

  ​	document、location、navigator、screen、history、frames

- DOM---文档对象模型,核心是document对象

  ​	document对象，元素节点对象(element对象)，事件对象(event对象)，attribute对象

| DOM                                      | BOM                                              |
| ---------------------------------------- | ------------------------------------------------ |
| 文档对象模型                             | 浏览器对象模型                                   |
| DOM 就是把「文档」当做一个「对象」来看待 | 把「浏览器」当做一个「对象」来看待               |
| DOM 的顶级对象是 `document`              | BOM 的顶级对象是 `window`                        |
| DOM 主要学习的是操作页面元素             | BOM 学习的是浏览器窗口交互的一些对象             |
| DOM 是W3C 标准规范                       | BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差 |

### canvas

应用：动画，游戏，合成图，海报等

优化方法：

1. 少使用font属性

2. 分层canvas(部分擦除重绘，类似dom部分更新)

获取绘图上下文，而取得上下文对象的引用，需要调用getContext()方法，并传入上下文参数"2d"，这样就能取得2D上下文对象。

```
		let canvas = document.querySelector('#mycanvas')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        window.addEventListener('resize', function () { //画布大小跟随窗口变
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
        })
        if (!canvas.getContext) return; //检查是否支持绘制对象]

        let ctx = canvas.getContext('2d') //获取绘制对象
        //.........
        //此处开始绘制代码
        //.........
        let imgURL = canvas.toDataURL("image/png"); //默认图片格式为png
```

ctx.lineWidth = 5;//设置线段宽度

ctx.strokeStyle= "blue"//设置描边颜色

ctx.fillStyle="blue"//设置填充颜色

ctx.stoke();//描边动作

ctx.fill();//填充动作

ctx.beginPath();//开始一条新的路径

ctx.moveTo(0,0);*//画笔移动到坐标为0，0的点上*

ctx.lineTo(200,100);*//连接两点成一条线*

ctx.closePath();//闭合路径

ctx.arc(x,y,r,start,stop,false);//画圆

ctx.strokeRect(x,y,width,height);//画矩形

ctx.clearRect(0,0,width,height);//清除画布

ctx.save() *//保存之前样式状态*

ctx.restore() *//回退一个样式状态版本*

### 7、css权重

css 权重大小顺序如下`!important > 内联样式 > ID > 类、伪类、属性 > 元素、伪元素 > 继承 > 通配符`，为了方便计算，有聪明的 boy 给每个等级定义了一个基数，即

- !important: 无穷大

- 内联样式: 1000

- ID: 100

- 类、伪类、属性: 10

- 元素、伪元素: 1

- 通配符: 0

  ```
  style=""                    => 1000(一个行内样式)
  #title{}                    => 100(一个ID选择器)
  .root                       => 10(一个类)
  [title]                     => 10(一个属性)
  div                         => 1(一个元素)
  *{}                         => 0(通配符)
  div span {}                 => 1+1=2(两个元素)
  div h1+span {}              => 1+1+1=2(三个元素)
  div:first-child             => 1+10=11(一个元素，一个伪类)
  div [title]                 => 1+10=11(一个元素，一个属性选择器)
  body #title .root p {}      => 112(1+100+10+1，两个元素，一个Id选择器，一个类)
  ```

### 8、媒体查询

```css
@media all and (min-width:320px) { 
    body { background-color:blue;}
 }

默认样式    注意：默认样式要写在最前面
    /* 打印样式 */
        @media print {}
    /* 手机等小屏幕手持设备 */
        @media screen and (min-width: 320px) and (max-width: 480px) {}
    /* 平板之类的宽度 1024 以下设备 */
        @media only screen and (min-width: 321px) and (max-width: 1024px) {}
    /* PC客户端或大屏幕设备: 1028px 至更大 */
        @media only screen and (min-width: 1029px) {}
    /* 竖屏 */
        @media screen and (orientation:portrait) {对应样式}
    /* 横屏 */
        @media screen and (orientation:landscape){对应样式}
```

### 9、新增特性

语义化标签特点：

代码结构清晰，方便阅读，有利于团队合作开发

有利于搜索引擎优化（SEO）

| <article>    | 定义页面独立的内容区域。                                     |
| ------------ | ------------------------------------------------------------ |
| <aside>      | 定义页面的侧边栏内容。                                       |
| <dbi>        | 允许您设置一段文本，使其脱离其父元素的文本方向设置。         |
| <command>    | 定义命令按钮，比如单选按钮、复选框或按钮                     |
| <details>    | 用于描述文档或文档某个部分的细节                             |
| <dialog>     | 定义对话框，比如提示框                                       |
| <summary>    | 标签包含 details 元素的标题                                  |
| <figure>     | 规定独立的流内容（图像、图表、照片、代码等等）。             |
| <figcaption> | 定义 <figure> 元素的标题                                     |
| <footer>     | 定义 section 或 document 的页脚。                            |
| <header>     | 定义了文档的头部区域                                         |
| <mark>       | 定义带有记号的文本。                                         |
| <metter>     | 定义度量衡。仅用于已知最大和最小值的度量。                   |
| <nav>        | 定义导航链接的部分。                                         |
| <progress>   | 定义任何类型的任务的进度。                                   |
| <ruby>       | 定义 ruby 注释（中文注音或字符）。                           |
| <rt>         | 定义字符（中文注音或字符）的解释或发音。                     |
| <rp>         | 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 |
| <section>    | 定义文档中的节（section、区段）。                            |
| <time>       | 定义日期或时间。                                             |
| <wbr>        | 规定在文本中的何处适合添加换行符。                           |

多媒体标签：

| video  | audio |
| ------ | ----- |
| source | embed |
| track  |       |

图形标签：canvas、SVG

###### **HTML5 表单属性**

 HTML5 的 <form> 和 <input>标签添加了几个新属性.

<form>新属性：

- autocomplete、novalidate

<input>新属性：

- autocomplete、autofocus、form、formaction、formenctype、formmethod、formnovalidate、formtarget、height and width、list、min and max、multiple、pattern (regexp)、placeholder、required、step

 HTML5 有以下新的表单元素:

| 标签       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| <datalist> | <input>标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 |
| <keygen>   | ><keygen> 标签规定用于表单的密钥对生成器字段。               |
| <output>   | <output> 标签定义不同类型的输出，比如脚本的输出。            |



### 10、display常用

```
display:none;设置元素隐藏

display:block;设置元素为块级元素，块级元素可以独占一行，可设宽高。
示例元素：div,h1-h6,ul,ol,dl,p

display:inline;设置元素为行内元素，一行可有多个行内块元素，不可设宽高。
示例元素：：span、a、label、input、 img、 strong 和em就是典型的行内元素元素。

display:inline-block：设置元素为行内块元素，既有行内元素的（一行可有多个）特性，又有块元素的（可设宽高）特性

display:flex 弹性盒子

display:table 元素会作为块级表格来显示，类似 table

display:grid 网格布局

```

**position的属性**
 1.position: relative;相对定位

不影响元素本身特性， 不会使元素脱离文档流， 没有定位偏移量时对元素无影响（相对于自身原本位置进行偏移），

提升层级（用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值越大越在上面，z-index只能在position属性值为relative或absolute或fixed的元素上有效。）  （两个都为定位元素，后面的会覆盖前面的定位）

 2.position: absolute 绝对定位

 使元素完全脱离文档流（在文档流中不再占位），使内联元素在设置宽高的时候支持宽高，使区块元素在未设置宽度时由内容撑开宽度，相对于最近一个有定位的父元素偏移（若其父元素没有定位则逐层上找，直到document——页面文档对象），相对定位一般配合绝对定位使用，提升层级

3.position: fixed 固定定位

生成固定定位的元素，相对于浏览器窗口进行定位。

4.position：static 默认值

默认布局。元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）

5.position： sticky 粘性定位

粘性定位，该定位基于用户滚动的位置。

它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。



### 11、主流浏览器内核

- IE:	Trident内核
- Firefox:	Gecko内核
- Safari:	Webkit内核
- Chrome/opera: 	Blink内核

### 12、经典布局

#### 经典布局

圣杯、双飞翼布局都是为了实现一个**两侧宽度固定，中间宽度自适应的三栏布局**

- ##### 圣杯布局

  父容器的左、右内边距+两个列的相对定位

- ##### 双飞翼布局

  主列嵌套在一个新的父级块中并利用主列的左、右外边距：
  
  1.使三元素左浮动
  
  2.center的width为100%
  
  3.left的margin-left为-100%(父元素的100%),就跑到上面去了,right的margin-left:-本身width,跑到上面的末尾去了
  
  4.content的margin 左右为两个侧边栏的width(为内容留下位置)
  
- ##### flex布局

  ```
  .container{
      display: flex;
  }
  .middle{
      flex: 1;
      background:yellow;
  }
  .left{
      width:200px;
      background:pink;
  }
  .right{
      background: aqua;
      width:300px;
  }
  ```
  
  
  
  - display:flex,形成弹性盒，添加在父元素之上。默认主轴就是x轴方向，水平向右row
    - 默认X轴为主轴，横向排列
    - 如果父元素为弹性盒，子元素就都能设置宽高
    - 如果父元素为弹性盒，让子元素在盒子里左右居中，，要给子元素添加margin：auto
    
  - flex-direction:改变主轴的排列方式（指定谁是主轴，添加在父元素上）
    - row指定X轴为主轴
    - column 指定Y轴为主轴
    - column-reserve 指定Y轴为主轴但是反向排列
    
    flex-flow: row wrap
    
  - justify-context:子元素在弹性合理的主轴对齐方式（添加在父元素上）
    - flex-start 弹性盒子开始的地方
    - flex-end 弹性盒子结束的地方
    - center 居中
    - space-between  两端对齐中间自动分配
    - space-around 完全自动分配
    
  - align-items: 侧轴的对齐方式（添加在父元素上）
    - flex-start
    - flex-end
    - center
    - baseline:默认情况下与flex-start相同
    
  - align-content:把所有看作一个整体合起来，一起居中
  
  - flex-wrap:是否换行
  
  - align-self: 侧轴方向单个的对齐方式
  
  - flex-basis宽度基准值，设置后width失效，以这个为准
  
  - flex-grow: 1; 在父元素中，剩余宽度所占比例------父元素宽度有多
  
  - flex-shrink: 1; 在父元素中，宽度不够要压缩所占比例------父元素宽度不够
  
  - 缩写flex:flex-grow flex-shrink flex-basis
  
  - `order`:定义项目的排列顺序。数值越小，排列越靠前，默认为0。

****

### 13、px、rem、em、vw、vx

px:px是绝对像素

rem:rem根据根元素的font-size的变化而变化

em：先找自身的font-size值，如没有就向上一级元素再找，直到找到为止

vw、vh:vw和vh就是根据窗口的宽高，把窗口分成100等分，是以视窗作为参考值的

100%：是以父元素的宽高为参考的

### 14、浏览器兼容

-moz-代表firefox浏览器私有属性；

-ms-代表IE浏览器私有属性；

-webkit-代表chrome、safari私有属性；

-o-代表Opera私有属性。

#### React兼容IE

##### Set、Map

```
React 16 依赖集合类型 Map 和 Set 。如果你要支持无法原生提供这些能力（例如 IE < 11）或实现不规范（例如 IE 11）的旧浏览器与设备，考虑在你的应用库中包含一个全局的 polyfill ，例如 core-js 或 babel-polyfill 。
```

给出的解决方案就是入口文件中提前引入指定的 polyfill:

```
import 'core-js/es/map';
import 'core-js/es/set';

import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
  <h1>Hello, world!</h1>,
  document.getElementById('root')
);
```

##### IE10文字超长换行问题

```
/*word-break: break-word;*/ IE10中不支持 
word-break: break-all;
```

##### IE接口请求使用缓存问题

```
这个问题的发现，是因为我们当时系统登陆进去之后，总是马上弹出来。但是开着F12，又每次都能登陆进去。

这个问题很神奇，从最初的以为登陆接口cookei信息没带上，到后来怀疑 fetch请求的兼容包whatwg-fetch没引入，一直到最后前后端一起定位发现是，登陆使用了上一次登陆的缓存返回，导致返回的还是未登陆状态。

结论：IE 里面接口请求如果没有控制缓存使用方式，浏览器可能会自动使用缓存，返回上一次请求的结果，但是如果打开F12调试，开启调试者模式，IE就不会使用缓存，注意此问题，如果不想接口请求使用缓存，可以用加时间戳的方法解决。
```

####  IE中的event

```
window.event
```





#### 任意兼容ie

```
!DOCTYPE html> 
<!--[if IE 8 ]> <html class="ie8" lang="en"> <![endif]--> 

<!--[if IE 9 ]> <html class="ie9" lang="en"> <![endif]--> 

<!--[if (gt IE 9)|!(IE)]><!--> 

<html lang="en"> <!--<![endif]-->
```



### 15、遮罩层穿透

​           pointer-events

> pointer-events是css属性，是一个与javascript有关的属性，pointer-events直译为指针事件，当把值设置为none后，他有如下相关特性

　	阻止用户的点击动作产生任何效果

　　阻止缺省鼠标指针的显示

　　阻止Css里的Hover和Active状态的变化触发事件

　　阻止Javascript点击动作触发的事件

作用：让里面一层可以得到触发

场景：提示用户可以滑动切换，那就添加了一个滑动动画。

滑动动画在最上层，所以当显示滑动提示显示的时候，用户切换就被它挡住了。所以想到pointer-events:none方法实现穿透。

### 16、设置超出显示省略号

```
  单行:
  overflow:hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  
  多行:
  overflow:hidden; 隐藏超出部分
  text-overflow: ellipsis; 文本省略部分替代超出的部分
  -webkit-line-clamp: 3; 限制一个块元素显示的文本行数
  display: -webkit-box; 弹性伸缩盒子模型
  -webkit-box-orient: vertical; 设置或检索伸缩盒对象的子元素的排列方式
```



***

## 十、算法

十大排序算法中相对稳定的两个

冒泡排序:

比较相邻的两个元素，如果前一个比后一个大，则交换位置.

第一轮的最后一个元素应该是最大的一个

```
function bubbleSort(arr) {
  var len = arr.length;
    for(var i = 0; i < len - 1; i++) {//循环的趟数
       for(var j = 0; j < len - 1 - i; j++) {
 // 每一趟把最大的往后挤后(放末尾)，挤完就不用管了，就不用再参加循环了，
 //5个数放4次就可以了， len - 1
           if(arr[j] > arr[j+1]) {    ``// 相邻元素两两对比
           vartemp = arr[j+1];    ``// 元素交换
           arr[j+1] = arr[j];
           arr[j] = temp;
       }
      }
    }
   return arr;
}
```

插入排序:

把数组里的第一个丢到新定义空数组里面表示已经被排序，然后从数组第二个开始遍历，依次跟新数组里面的每一个数比较，从后往前比较，如果比新数组里的某个数大就splice插入这个数的后面(索引加1)black终止循环，如果一直循环到新数组第一项还没找到，unshift就放在新数组第一项

```
    // 插入排序
        function insertSort(array) {
            //1.准备一个数组，来存储抓的牌，一开始先抓一张
            let handle = []
            handle.push(arr[0])
            //2.从第二张开始依次抓，一直到牌抓光
            for (let i = 1; i < array.length; i++) {
                const A = array[i];
                for (let j = handle.length - 1; j >= 0; j--) {
                    const B = handle[j];
                    if(A>B){
                        handle.splice(j+1,0,A)
                        break;
                    }
                    //比到第一项，把牌放到最前面
                    if(j==0){
                        handle.unshift(A)
                    }
                }
            }
            return handle;
        }
```



https://www.cnblogs.com/onepixel/articles/7674659.html

## 十一、设计模式

要会的三种设计模式：单例模式、观察者模式、发布-订阅者模式

其它https://juejin.im/post/6844903846523699214



1.单例模式

思想：保证一个类只有一个实例，并提供一个全局访问点。实现方法：先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

2.发布订阅模式 (观察者模式)

思想：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会for循环得到通知并被自动更新。

3、策略模式

定义一组算法(封装一组函数)，将每个算法都封装起来，并且使他们之间可以相互替换

**优点**

可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护

**缺点**

往往策略集会比较多，我们需要事先就了解定义好所有的情况

4、适配器模式

将两个不能一块工作的接口或者类，通过新建一个类继承两者，从而使得可以一起工作

## 十二、为什么JavaScript会有精度问题？

因为Js中所有的数字遵循IEEE 754标准，也就是标准的double双精度浮点数。计算的时候会转换成二进制计算进制转换之后会很长，舍去一部分，计算后再转成十进制。，就有了精度误差。

它的优点是可以归一化处理整数和小数，节省储存空间。

## 十三、埋点

**作用**：线上如果裸奔，出现了什么问题不知道，监控用户的操作行为，统计用户端产品的使用情况，包含页面点击量、用户点击流、用户访问路径、用户点击热力图、用户转化率、导流转化率、用户访问时长分析和用户访问内容等

### 埋点监控的职能范围

**用户行为监控**

负责统计PV（页面访问次数）、UV（页面访问人数）以及用户的点击操作等行为。

这类统计是用的最多的，有了这些数据才能量化我们的工作成果。

**页面性能监控**

开发和测试人员固然在上线之前会对这些数据做评估，但用户的环境和我们不一样，也许是3G网，也许是很老的机型，我们需要知道在实际使用场景中的性能数据，比如页面加载时间、白屏时间等。

**错误报警监控**

获取错误数据，及时处理才能避免大量用户受到影响。除了全局捕获到的错误信息，还有在代码内部被catch住的错误告警，这些都需要被收集到。

**需要统计:**

- *接口地址*
- *点击事件：事件名字*，事件参数
- 上报事件的类型
- 上报的时间戳
- 用户身份信息
- 页面停留时长
- 触发上报事件的元素
- 异常捕获上报
- data（自定义数据)
- 当前、上一个页面的 url
- 浏览器信息
- ...

### **代码埋点/手动埋点：**

第一种：自己公司研发在产品中注入代码统计，并搭建起相应的后台查询

第二种：可以使用第三方sdk埋点。如百度统计、 神策、友盟、TalkingData、Google Analytics、Sensors Analytics等

vue 可以**封装指令监控按钮点击、路由守卫计算页面停留时间及访问页面url**

#### **埋点数据上报的形式**

- xhr上报

  - 适用于需要接受数据上报后的返回结果进行回调处理

- 创建img/iframe/script上报

  - ```
    const sendData = (params: object) => {
      const sendScript = document.createElement('script');
      const requestAddress =
        process.env.NODE_ENV === 'development'
          ? `http://localhost:9999/saveComponentLog?info=${JSON.stringify(params)}`
          : `http://react-view-ui.com:9999/saveComponentLog?info=${JSON.stringify(params)}`;
      sendScript.src = requestAddress;
      sendScript.async = true;
      document.body.appendChild(sendScript);
      return new Promise((resolve, reject) => {
        sendScript.onload = () => {
          try {
            document.body.removeChild(sendScript);
            resolve('');
          } catch (e) {
            reject(e);
          }
        };
      });
    };
    export default sendData;
    
    
    ```

  - 采用`img`的`src`属性发送的原因有下：

    - 没有跨域的限制，像srcipt标签、img标签都可以直接发送跨域的GET请求，不用做特殊处理。
    - 兼容性好，不需要插入DOM，影响页面性能，一些静态页面可能禁用了脚本，这时script标签就不能使用了。
    - 一般使用GIF，因为相比PNG/JPG，GIF的体积最小

  - ```
    let baseURL = 'https://www......'
    let queryStr = Object.entries(query).map(([key, value]) => `${key}=${value}`).join('&')
    let img = new Image();
    img.src = `${baseURL}?${queryStr}`
    
    ```

### **可视化埋点**

可视化埋点即以业务代码为输入，通过可视化系统配置埋点，最后以耦合的形式输出业务代码和埋点代码，但是可视化系统的埋点控件有限，并不能充分满足埋点需求。

可视化埋点的流程通常为：

输入页面的url => 页面加载完成后 => 配置可视化的工具 => 点击创建事件（click） => 进入元素选择模式 => 用鼠标点击页面上的某个元素（例如button、a这些element）=> 就可以在弹出的对话框里面 => 设置这个事件的名称（比如叫TEST），选上报数据属性（properties）=> 保存配置 => 用户访问点击按钮 => 数据上报

### **无埋点**

无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。优点是前端只要一次加载埋点脚本，不会出现漏埋、错埋等情况。缺点是流量和采集的数据过于庞大，服务器性能压力大。

### 错误监控

页面的用户行为监控及页面性能监控可能不是必须的，但是错误监控是所有的页面必须的
页面中的代码建议都加上`try/catch`，它能捕获常规运行错误，但是语法错误和异步错误不行。

```javascript
try {
  console.log(notdefined);
} catch(e) {
  console.log('捕获到异常：', e);
}
```

`window.onerror`能捕获常规运行错误，异步错误也可捕获，但是不能捕获语法错误及资源加载错误。

```javascript
window.onerror = function(message, source, lineno, colno, error) {
  console.log('捕获到异常：',{message, source, lineno, colno, error});
}
console.log(notdefined);
```

`window.addEventListener`能捕获常规运行错误、异步错误及资源加载错误，但是不能捕获语法错误、new Image错误及fetch错误。

```javascript
window.addEventListener('error', (error) => {
    console.log('捕获到异常：', error);
}, true)
```

以上方法都不能捕获`promise`类型的错误，要捕获`promise`类型的错误需要通过`unhandledrejection`捕获。

```javascript
window.addEventListener("unhandledrejection", function(e){
  console.log('捕获到异常：', e);
});
```

由于Vue会捕获所有Vue单文件组件或者Vue.extend继承的代码，所以在Vue里面出现的错误，并不会直接被window.onerror捕获，而是会抛给Vue.config.errorHandler。

```javascript
Vue.config.errorHandler = function (err) {
  setTimeout(() => {
    throw err
  })
}
```

一般有两张表，用户信息表和错误表。

### SDK设计

使用

```javascript
import StatisticSDK from 'StatisticSDK';
// 全局初始化一次
window.insSDK = new StatisticSDK('uuid-12345');


<button onClick={()=>{
  window.insSDK.event('click','confirm');
  ...// 其他业务代码
}}>确认</button>
```

首先把SDK实例挂载到全局，之后在业务代码中调用，这里的新建实例时需要传入一个id，因为这个埋点监控系统往往是给多个业务去使用的，通过id去区分不同的数据来源。

```javascript
class StatisticSDK {
  constructor(productID){
    this.productID = productID;
    // 初始化错误监控
    this.initError()
  }
  // 数据发送
  send(baseURL,query={}){
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) => `${key}=${value}`).join('&')
      let img = new Image();
      img.src = `${baseURL}?${queryStr}`
  }
  // 自定义错误上报
  error(err, etraInfo={}) {
    const errorURL = 'http://error/'
    const { message, stack } = err;
    this.send(errorURL, { message, stack, ...etraInfo})
  }
  // 初始化错误监控
  initError(){
    window.addEventListener('error', event=>{
      this.error(error);
    })
    window.addEventListener('unhandledrejection', event=>{
      this.error(new Error(event.reason), { type: 'unhandledrejection'})
    })
  }
}
```

**如何在页面卸载的时候向远端web服务器发送请求？**

`因为如果你想在页面卸载、刷新或跳转前发送请求，这个请求绝大多数情况下会被浏览器 canceled 掉`

**navigator.sendBeacon()**

这个方法主要用于满足统计和诊断代码的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。

```js
const sendBeacon = (url, data = {}) => {
  const joinedQueue = navigator.sendBeacon(url, JSON.stringify(data));
  console.log('用户代理把数据加入传输队列' + (joinedQueue ? '成功' : '失败'));
}
```

- 通过 HTTP POST 将少量数据异步传输，可靠性好
- sendBeacon()第二个参数可接受**ArrayBufferView**、**Blob**、**FormData**、**DOMString**类型的数据。
- sendBeacon()会根据传入的数据自动设置请求头，数据类型和对应Content-Type
- 不会阻塞页面卸载,也就不会影响下一导航的载入
- **不支持自定义请求头**

## 十四、前端性能优化

##### **性能优化的重点**：<font color='red'>**加载、缓存**</font>

  （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

  （2） 前端模板 JS+数据，减少由于HTML标签导致的[带宽](频带的宽度。在通信中，指某一频带最高频率和最低频率的差（单位是赫兹）；在计算机网络中，指数据传输能力的大小（单位是比特/秒)浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

  （4） 当需要设置的样式很多时设置className而不是直接操作style。

  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

  （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

  （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

  （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。

#### 前端 SEO优化

1）网站的结构优化：

①控制首页的链接数量；

②目录结构的层次不要超过3层；

③导航尽量使用文字形式的导航，如果加上图片了必须给img图片增加alt与title属性，可以的话尽量使用面包屑导航；

④页面的结构布局；头部展示logo、导航、用户信息，主体展示内容； 底部展示版权信息以及友情链接等；

⑤控制页面的大小，最好不要超过100K，页面太大自然加载速度慢，不利于 seo

2）网站的代码优化：

①header 标签的 title 标签尽量强调页面的主题即可，里面的关键字尽量不要重复，尽量每个页面的关键字不要出现重复；

②<meta keywords>和title标签的意思差不多，尽量关键字不要出现重复；

③<meta description> 网页的描述，和上面两个的意思差不多；

④body标签中的结构标签，尽量使用语义化标签，例如 header，footer，main，aside等

⑤a 标签，必须加上title 属性，如果a标签是外部链接，则需加上 el='nofollow'，不然搜索引擎就会跳转到外部链接所在的网站；

⑥h 标签，一个页面中只能出现一个 h1标签，其他的副标题使用h2~h6标签

⑦br 标签，只使用在文本内容的换行；

⑧表格标签中尽量使用 caption 展示表格标题；

⑨strong 与 em 标签尽量在强调的时候用，strong标签在搜索引擎中能得到高度重视，em 的重视程度仅此于 strong；b 标签 i标签只是用于展示效果，于seo没有任何作用；

⑩文本缩进不要使用&nbsp，应该使用css的 text-indent 设置；版权不要使用&copy，使用输入法中的版权符号；

11、img标签必须加 alt属性加以说明；

12、谨慎使用 display:none；因为搜索引擎会过滤其中的内容；

13、js代码如果使用了 dom 操作，应该尽量放在body标签结束之前，html代码之后；

14、重要内容不要用 js 输出

15、尽量不要使用iframe框架，因为搜索引擎一般不会爬取里面的内容。



### 如何优化自己的代码

1. 代码重用
2. 避免全局变量（命名空间，封闭空间，模块化mvc..）
3. 拆分函数避免函数过于臃肿
4. 注释

****



## 十五、跨平台开发、小程序

#### 微信小程序组件之间数据传递

**1.父组件向子组件传值: **子组件是通过 properties 来接收父组件传递过来的值

**2.子组件向父组件传值: **子组件通过 triggerEvent 方法向父组件传值

案例描述：点击按钮出现弹层，弹层为子组件；点击弹层中的关闭，关闭弹层；

父传子：

json文件:声明子组件

```javascript
{
  "usingComponents": {
    "tem-baomingtan": "/components/baomingtan/baomingtan"
  }
}

```

页面中使用子组件：在子组件上传值给子组件

```javascript
<view class="lijibm" bindtap="lijibm">立即报名</view>
<tem-baomingtan isinfotan="{{isinfotan}}" />

```

js文件：点击修改数据

```javascript
data: {
	isinfotan: false
},
lijibm: function () {
    this.setData({
      isinfotan: true
    })
  }

```

子组件：

```javascript
<view class="infoboxtan" wx:if="{{isinfotan}}">
	<image src="../../images/close-xx.png" mode="widthFix" class="close" bindtap="closeinfo" />
	<!-- ... -->
</view>

```

子传父:

js: properties 接收父组件传来的值，点击关闭事件closeinfo（），加一个触发事件infotan，传值给父组件；

```javascript
  properties: {
    isinfotan: Boolean
  },
  methods: {
	  closeinfo:function() {
	    this.triggerEvent('infotan', {
	      isinfotan: false
	    });
	  }
  }

```

父组件页面中接收子组件的触发事件：

```javascript
<view class="lijibm" bindtap="lijibm">立即报名</view>
<tem-baomingtan isinfotan="{{isinfotan}}" bind:infotan="infotan" />

```

父js: infotan获取子组件传来的值

```javascript
data: {
	isinfotan: false
},
  lijibm: function () {
    this.setData({
      isinfotan: true
    })
  },
  infotan: function (e) {
    this.setData({
      isinfotan: e.detail.isinfotan
    })
  },

```

#### 小程序页面跳转传参,页面跳转的方式和他们之间区别?

- wx.navigator标签来实现页面跳转，但是不能跳到 tabbar 页面，使用wx.navigateBack 可以返回到原页面。
- wx.switchTab()跳转到 tabBar 页面
- wx.redirectTo跳转到应用内的某个页面，但是不允许跳转到 tabbar 页面
- wx.reLaunch关闭所有页面，打开到应用内的某个页面
- 最后在被打开页面利用**options**参数来获取传递的数据

```
wx.reLaunch({
  url: 'test?id=1'
})
Page({
  onLoad (option) {
    console.log(option.query)
  }
})
```



####  小程序开发：

登录流程、支付、授权、生命周期、地理定位

**登录流程**

```

wx.login()获取code  为了能获取openid唯一标识和sessionkey
wx.request()发送code到开发者服务器(后台)

开发者服务器(后台)，传appid、appsecret、code到微信服务器
微信服务器返回session_key、openid

通过自定义登录态与openid、session_key关联
返回自定义登录态

存入storage

wx.request()发起业务请求携带自定义登录态
开发者服务器通过自定义登录态，查询openid和session_key

正确返回业务数据到用户


```

**支付**

```
小程序内调用登录接口，获取到用户的openid,api参见公共api 小程序登录API

商户server调用支付统一下单，api参见公共api 统一下单API

商户server调用再次签名，api参见公共api 再次签名

商户server接收支付通知，api参见公共api 支付结果通知API

商户server查询支付结果，api参见公共api 查询订单API
```

**授权**

```
一、检查是否授权过
小程序端通过调用wx.getSetting()接口可以在成功的回调里获取到所有已经授权过的信息。
这里需要小程序端进行判断，如果已经授权过就可以直接调用相应的接口，如果没有授权，需要提示去授权或者直接跳转到授权页。

二、授权页
用户通过点击<button open-type="getUserInfo" bindgetuserinfo="onGotUserInfo"/>弹出授权弹窗，如果同意授权则可以从bindgetuserinfo回调中获取到用户信息。

现在微信调整为getUserProfile获取用户个人信息，wx.getUserInfo无效

三、设置界面
现调整为只能通过点击<button open-type="openSetting">按钮跳转至设置界面(wx.openSetting)

当然也可以[右上角] - [关于] - [右上角] - [设置]打开设置界面，设置界面只会出现已经授权过的的权限信息。在这里可以自由设置权限。


```

获取用户手机号

```

1、必须先调用login接口，如果没有调用login点击button时会提示先调用login。使用wx.login得到的登陆凭证code，传给后台用于换取session_key
2、用户点击获取用户手机号码按钮
<button open-type='getPhoneNumber' bindgetphonenumber="getPhoneNumber">获取用户手机号</button>
3、弹出授权
4、wx.checkSession，检查session_key 是否已经失效，需要重新执行登录流程wxlogin
5、通过bindgetphonenumber绑定的事件来获取回调。回调的参数有三个，
	errMsg：用户点击取消或授权的信息回调。
	iv：加密算法的初始向量（如果用户没有同意授权则为undefined）。
	encryptedData： 用户信息的加密数据（如果用户没有同意授权同样返回undefined）
	
	把encryptedData、iv、session_key传给后台，后台调微信侧服务器，进行手机号解密

```

获取用户地址信息

```
 1、wx.getSetting//先查看授权信息，判断是否授权
 wx.getSetting({
    success (res) {
      if(res.authSetting['scope.userLocation']){}
    }
  })
 2、如果没有授权，wx.authorize获取授权；或者wx.openSetting打开设置，让用户开启授权
 3、wx.getLocation获取经纬度--->然后利用腾讯地图SDK，使用逆地址解析(传入注册腾讯地图时的key)，获取地址信息; 或使用wx.chooseLocation打开地图选择位置获取地址信息(不建议)
```



**生命周期**

![img](https://img2018.cnblogs.com/blog/1389036/201906/1389036-20190605153614565-1305707081.png)

```

```

![img](https://img2018.cnblogs.com/blog/1389036/201906/1389036-20190605153628194-766266922.png)

![img](https://img2018.cnblogs.com/blog/1389036/201906/1389036-20190605153929082-443969871.png)

#### uniapp打包流程

跨平台开发：一套代码，多处运行  uniapp

1.uniapp用Hbuilder X 直接打包成app，打包前可在manifest.json 配置打包项(权限)

- uniapp-id，应用名称，应用描述，版本号
- 启动图配置 ，权限配置
- 如需推送需选择消息推送

2.云打包

```
	IOS 版本：使用苹果开发者账号登录 iOS Dev Center，申请苹果 App ID(App的唯一标识) ，证书密码 ，证书描述文件，私钥证书 ----- > 该证书可向公司索取
```

​		Android 版本： 使用DCloud公用证书

打包还能插入广告，在uni统计选择打开关闭/查看用户量

```
 uni.$emit('login',{msg:'页面更新'})
 // 我的页面  
onLoad(){  
    // 监听事件  
    uni.$on('login',(usnerinfo)=>{  
        this.usnerinfo = usnerinfo;  
    })  
},  
onUnload() {  
    // 移除监听事件  
        uni.$off('login');  
    },
```

uni.navigateTo()进行页面的跳转传值，onLoad(options)接收值



应用生命周期onLaunch,初始化完成时触发（全局只触发一次）,onShow当 `uni-app` 启动,onHide,onError,onThemeChange监听系统主题变化

页面生命周期

通用:onLoad,onShow，onReady初次渲染之后触发，onHide,onUnload,onPullDownRefresh,onReachBottom

beforeCreate => onLoad => onShow => created => beforeMount => onReady => mounted

onInit触发时机早于 onLoad，onResize监听窗口尺寸变化，onShareAppMessage用户点击右上角分享，onPageScroll监听页面滚动，参数为Object都会有一定的兼容性问题

组件生命周期跟vue一样

------

uni.setStorage,uni.getStorage

uni.chooseFile选择文件,uni.uploadFile上传文件,uni.downloadFile下载文件

uni.connectSocket创建连接,uni.onSocketOpen打开连接，uni.sendSocketMessage发送,onSocketMessage接收，uni.closeSocket();

uni.addInterceptor请求拦截器

 预览图片 uni.previewImage

## [条件编译](https://uniapp.dcloud.io/platform?id=条件编译)

条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。

## 全局缓存

```cpp
存入

getApp().globalData.test1 = "老狗"
getApp().globalData.test2 = "老猫"</pre>

取出

let {test1,test2} = getApp().globalData;
```

解决后端服务跨域问题

在根目录 manifest.json 中，外置浏览器跨域,在内置浏览器请求时不会出现这个问题

```
 "h5" : {
       "devServer" : {
           "https" : false,
           "port": 80,
           "disableHostCheck": true,
           "proxy": {
               "/api": {
                   "target": "http://wthrcdn.etouch.cn",
                   "changeOrigin": true,
                   "secure": false,
                   "pathRewrite":{"^/api":""}
               },
          "/douban": {
                   "target": "https://www.douban.com",
                   "changeOrigin": true,
                   "secure": false,
                   "pathRewrite":{"^/douban":""}
               }
           }
       }
   }
```

ios端`不支持文字渐变的`css,uni里不支持对dom节点的操作

uni-app request POST 请求方式不加 header头会默认为 OPTIONS，因此在进行post请求时。记得加上头部信息